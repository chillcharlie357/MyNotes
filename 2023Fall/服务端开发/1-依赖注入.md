
Git：分布式版本控制
Beam:java中一个对象，Spring负责对象创建、管理这些对象


![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F07%2F27a33f228b702e3362eab03541d8c21e_20230907191141.png)

商品服务需要引用库存服务（依赖），如何知道库存服务的地址/引用？
# 1. Spring核心技术

1. DI（Dependency Injection）
   - 保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，**由抽象接口来注入依赖的实际对象**
2. AOP（Aspect Oriented Programming）
   - 通过预编译方式和运行期间动态代理实现程序功 能的统一维护的一种技术
   - 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提 高程序的可重用性，同时提高了开发效率

# 2. 常用注解
## 2.1. Bean

==Object=Bean=Component==

- `@Component`
	- 普通的Java类加`@Component`注解，Spring会**实例化**这个类
	- Component value属性，指定Bean Id，默认为类名
- `@Autowired`
	- **自动注入**，Spring从从容器的上下文找实现了某个接口的对象
	- 找不到对象，注入失败
	- 找到多个实现了这个接口的对象，也会报错

- 自动装配时歧义：如何解决Bean冲突?
	- `@Qualifier`
	- `@Primary`在Bean上放指定

@Profile需要在不同场景下运行不同Bean
@Conditional在运行环境下决定Bean是否要创建
### 2.1.1. Bean三种注入方法👍

- 构造方法
- setter方法
- 私有属性字段下加`@Autowired`
## 2.2. 组件扫描

```java
@Configuration
@ComponentScan //找当前包下加了注解的类并实例化
public class CDPlaterConfig {
	@Bean
	<function>
}
```

- @ComponentScan //找当前包下加了注解的类并实例化
	- `basePackages`
		- 是数组可以写多个
		- 但是类型不安全，写错编译器不会报错
	- `basePackageClasses`
		- 也是数组
		- 到类所在的包和子目录下搜索
		- **类型安全**，但无法保证类一直存在


# 3. Spring配置方案👍

1. 自动配置
2. JavaConfig
3. XML配置（最早期）

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F14%2Fc81a655bf33d1187cac863eabe4a64de_20230914190947.png)
_SgtPeppers是一张CD_

建议基于接口编程

## 3.1. 自动配置

- 组件扫描 component scanning
	- `@Configuration` 配置类
	- `@ComponentScan`
- 自动装配 autowiring
	- `@Autowired`
	- 构造方法
	- 字段
	- set属性
- 需要实例化的Bean：`@Component`
	- 默认是单实例模式，在Spring上下文永远只有一个实例
	- 可以参数指定多实例


## 3.2. JavaConfig

- 应用场景：自动化配置行不通，如第三方库
- 注解
	- `@Configuration`
	- `@Bean(name=“..”)`


只用于创建，不会把业务逻辑放进来。
## 3.3. XML

- 格式：`<beans><bean>`

**无类型检查**

## 3.4. 混合配置

在根配置类中导入其他配置类。

- JavaConfig导入
	- `@import(配置类,class,...)`
	- `@importResource(xml文件)`
- XML导入
# 4. 应用上下文

1. AnnotationConfigApplicationContext
	- 基于注解配置生成
2. ClassPathXmlApplicationContext
3. AnnotationConfigWebApplicationContext
4. FileSystemXmlApplicationContext
5. XmlWebApplicationContext


# 5. Bean作用域

@Scope与@Component和@Bean一起使用，指定作用域

1. Singleton，单例。整个应用之创建一个实例
2. Prototype
3. Session，会话。在会话范围内有效
4. Request

## 5.1. 单例

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2Fbcf741e46f28882a4c83561481669afc_20230921185636.png)

通过代理注入给单例对象

# 6. 运行时注入外部值

1. 使用`Environment`属性
2. 使用`@PropertySource(/path/to/file)`指定文件

