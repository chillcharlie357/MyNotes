---
aliases: 
tags:
  - 2023_Fall_服务端开发
  - 课程
categories: 2023_Fall_服务端开发
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 1-依赖注入
date:  Tuesday,October 10th 2023
modified:  Thursday,December 28th 2023
---

Git：分布式版本控制  
Beam:java中一个对象，Spring负责对象创建、管理这些对象

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F07%2F27a33f228b702e3362eab03541d8c21e_20230907191141.png)

商品服务需要引用库存服务（依赖），如何知道库存服务的地址/引用？

# 1. Spring核心技术

1. DI（Dependency Injection）
   - 保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，**由抽象接口来注入依赖的实际对象**
2. AOP（Aspect Oriented Programming）
   - 通过预编译方式和运行期间动态代理实现程序功 能的统一维护的一种技术
   - 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提 高程序的可重用性，同时提高了开发效率

# 2. 常用注解

## 2.1. Bean

==Object=Bean=Component==

- `@Component`
	- 普通的Java类加`@Component`注解，Spring会**实例化**这个类
	- Component value属性，指定Bean Id，默认为类名
- `@Autowired`
	- **自动注入**，Spring从从容器的上下文找实现了某个接口的对象
	- 找不到对象，注入失败
	- 找到多个实现了这个接口的对象，也会报错

- 自动装配时歧义：如何解决Bean冲突?
	- `@Qualifier`
	- `@Primary`在Bean上放指定

@Profile需要在不同场景下运行不同Bean  
@Conditional在运行环境下决定Bean是否要创建

## 2.2. 组件扫描

```java
@Configuration
@ComponentScan //找当前包下加了注解的类并实例化
public class CDPlaterConfig {
	@Bean
	<function>
}
```

- `@ComponentScan` //找当前包下加了注解的类并实例化
	- `basePackages`
		- 是数组可以写多个
		- 但是类型不安全，写错编译器不会报错
	- `basePackageClasses`
		- 也是数组
		- 到类所在的包和子目录下搜索
		- **类型安全**，但无法保证类一直存在

当使用 `@ComponentScan` 注解时，Spring会自动扫描指定包下的组件，并将其注册为Bean。如果你在配置类中手动定义了相同的Bean，那么就会导致重复定义的问题。

## 2.3. Bean三种注入方法👍

### 2.3.1. 构造方法

	- 在构造函数上使用 @Autowired 注解，用于自动注入构造函数参数所需要的 Bean。如果构造函数只有一个参数，则可以省略 @Autowired 注解。

```java
@Autowired
public MyService(MyDao myDao) {
    this.myDao = myDao;
}
```

### 2.3.2. setter方法

```java
public void setOrderRepo(OrderRepository orderRepo) {
    this.orderRepo = orderRepo;
}
```

也可以加`Autowired`自动注入.

```java
@Autowired
public void setOrderRepo(OrderRepository orderRepo) {
    this.orderRepo = orderRepo;
}
```

### 2.3.3. 属性字段下加`@Autowired`

```java
@Autowired
private MyBean myBean;
```

# 3. Spring配置方案👍

1. 自动配置
2. JavaConfig
3. XML配置（最早期）

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F14%2Fc81a655bf33d1187cac863eabe4a64de_20230914190947.png)  
_SgtPeppers是一张CD_

建议基于接口编程

## 3.1. 自动配置

- 组件扫描 component scanning
	- `@Configuration` 配置类
	- `@ComponentScan`
- 自动装配 autowiring
	- `@Autowired`
	- 构造方法
	- 字段
	- set属性
- 需要实例化的Bean：`@Component`
	- 默认是单实例模式，在Spring上下文永远只有一个实例
	- 可以参数指定多实例

## 3.2. JavaConfig

- 应用场景：自动化配置行不通，如第三方库
- 注解
	- `@Configuration`
	- `@Bean(name=“..”)`

只用于创建，不会把业务逻辑放进来。

## 3.3. XML

- 格式：`<beans><bean>`

**无类型检查**

## 3.4. 混合配置

在根配置类中导入其他配置类。

- JavaConfig导入
	- `@import(配置类,class,...)`
	- `@importResource(xml文件)`
- XML导入

# 4. 应用上下文

1. AnnotationConfigApplicationContext
	- 基于注解配置生成
2. ClassPathXmlApplicationContext
3. AnnotationConfigWebApplicationContext
4. FileSystemXmlApplicationContext
5. XmlWebApplicationContext

# 5. Bean作用域

@Scope与@Component和@Bean一起使用，指定作用域

1. Singleton，单例。整个应用之创建一个实例
2. Prototype
3. Session，会话。在会话范围内有效
4. Request

## 5.1. 单例

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2Fbcf741e46f28882a4c83561481669afc_20230921185636.png)

通过代理注入给单例对象

# 6. 运行时注入外部值

1. 使用`Environment`属性
2. 使用`@PropertySource(/path/to/file)`指定文件

