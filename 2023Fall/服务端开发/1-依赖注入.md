
Git：分布式版本控制
Beam:java中一个对象，Spring负责对象创建、管理这些对象


![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F07%2F27a33f228b702e3362eab03541d8c21e_20230907191141.png)

商品服务需要引用库存服务（依赖），如何知道库存服务的地址/引用？

# Spring配置方案

1. 自动配置
2. JavaConfig
3. XML配置（最早期）

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F14%2Fc81a655bf33d1187cac863eabe4a64de_20230914190947.png)
_SgtPeppers是一张CD_

建议基于接口编程

## 自动配置

## Bean

==Object=Bean=Component==

- `@Component`
	- 普通的Java类加`@Component`注解，Spring会**实例化**这个类
	- Component value属性，指定Bean Id，默认为类名
- `@Autowired`
	- **自动注入**，Spring从从容器的上下文找实现了某个接口的对象
	- 找不到对象，注入失败
	- 找到多个实现了这个接口的对象，也会报错

- 如何解决Bean冲突?
	- `@Qualifier`
	- `@Primary`

- autowired三种注入方式写法

### 入口配置类

```java
@Configuration
@ComponentScan //找当前包下加了注解的类并实例化
public class CDPlaterConfig {
}
```

- @ComponentScan //找当前包下加了注解的类并实例化
	- `basePackages`
		- 是数组可以写多个
		- 但是类型不安全，写错编译器不会报错
	- `basePackageClasses`
		- 也是数组
		- 到类所在的包和子目录下搜索
		- 类型安全，但无法保证类一直存在


## JavaConfig


## XML


# 应用上下文

1. AnnotationConfigApplicationContext
	- 基于注解配置生成
2. ClassPathXmlApplicationContext
3. AnnotationConfigWebApplicationContext
4. FileSystemXmlApplicationContext
5. XmlWebApplicationContext