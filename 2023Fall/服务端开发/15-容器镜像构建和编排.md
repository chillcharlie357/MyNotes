---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 15-容器镜像构建和编排
date:  Thursday,December 21st 2023
modified:  Thursday,December 21st 2023
---

# 由Dockerfile构建镜像

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F21%2F18-48-00-e370271f15d63a6c253c9948ac97824b-20231221184759-c0bcd1.png)

## 文件指令

- FROM：**指定基础镜像，必须为第一个命令**
- RUN：构建镜像时执行的命令
- ADD：将本地文件添加到容器中，**tar类型文件会自动解压**
- COPY：功能类似ADD，但是**不会自动解压文件**
- CMD：**构建容器后调用，也就是在容器启动时才进行调用**
	- 可以手动覆盖
- ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去“application”，只使用参数，用于docker run时根据不同参数执行不同功能
	- 很可能是shell脚本
- LABEL：用于为镜像添加元数据
	- key-value
- ENV：设置环境变量
- EXPOSE：指定与外界交互的端口，容器内的端口号，docker run时加-P则会映射一个随机号（宿主机）
- VOLUME：用于指定持久化目录，docker run时如果没有指定挂载目录，会创建一个volume
- WORKDIR：工作目录，类似于cd命令
- USER：指定运行容器时的用户名或 UID
	- 默认root
- ARG：用于指定传递给构建运行时的变量
- ONBUILD：用于设置镜像触发器
	- 可以被其他人进一步构建，会触发一些行为

# Docker build

## 构建命令

- docker build [OPTIONS] PATH | URL | -

- 生成镜像：`docker build -t  <image>:<tag> .`
	- 最后一个参数context: .

## 最佳实践

- 如何编写dockerfile: [如何编写最佳的Dockerfile - 知乎](https://zhuanlan.zhihu.com/p/26904830)
	- .dockerignore文件
	- 容器只运行**单个应用**
		- 解耦，外来可以单独对一个应用进行升级/重启/...
	- 将多个RUN指令合并为一个
		- 原因：减少镜像分层
	- 基础镜像的标签不要用latest
		- 建议使用固定的版本，使得镜像可预知
	- 每个RUN指令后删除多余文件
		- 原因：否则，虽然在下一个RUN删掉，上一层的文件还在（写时复制，上一层不可修改）
	- 选择合适的基础镜像(alpine版本最好)
	- 设置WORKDIR和 CMD
	- 合理安排COPY和RUN的顺序
		- 把不容易改变的放在前面，充分利用缓存

- Docker健康检查HEALTHCHECK的使用方法：[Docker健康检查HEALTHCHECK的使用方法 - 知乎](https://zhuanlan.zhihu.com/p/386986915)

## 镜像分层

Dockerfile里每一条命令都会生成一个新的层，重复构建时有cache, 只从修改的层开始重新构建.

- 写时复制 COW
- docker history 查看镜像的层

- 将所有的RUN指令合并为一个
	- Dockerfile中的每个指令都会创建一个新的镜像层
	- 镜像层将被缓存和复用
	- 当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效
	- 某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效
	- 镜像层是不可变的，如果我们在某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)

## Docker精简版本

Alpine

