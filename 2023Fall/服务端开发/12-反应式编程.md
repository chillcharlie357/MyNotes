---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 12-反应式编程
date:  Thursday,November 30th 2023
modified:  Thursday,November 30th 2023
---

# 使用场景

- IO密集型场景
- 同步阻塞模型，阻塞线程多，CPU利用率不高，性能下降
- 管理多线程，意味着更高的复杂性

# Reactor

- Reactive Streams：Netflix、Lightbend和Pirotal于2013年开始制定的**一种规范**，旨在提供无阻塞回压的异步流处理标准
	- 和JDK里的Stream不是同一个东西

# Java的stream与反应式的流区别

1. **Java的stream通常都是同步的**，并且只能处理有限的数据集，本质上来说，它们只是使用函数来对集合进行迭代的一种方式
2. JDK9中的 **Flow API对应反应式流**

# 反应式流规范定义的4个接口

- org.reactivestreams.*

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-07-41-798ed044f2aa4ce418bbeb6519cfa668-20231130190741-06575a.png)

- Publisher：数据发布者
- Subscriber：数据订阅者
- Peocessor：处理器
- Subscription：协调

处理过程是异步的  
消费者驱动，消费者去请求发布者才会发布数据

# 基本概念

1. Flux：包含 0 到 N 个元素的异步序列
2. Mono：包含 0 或者 1 个元素的异步序列
3. 消息：正常的包含元素的消息、序列结束的消息和序列出错的消息
4. 操作符（Operator）：对流上元素的操作

# 反应式流图 

## Flux

Flux：发送0-n个元素的异步序列

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-50-28-2478db88115146681d4269a2e67204e8-20231130195028-f96d09.png)

## Mono

Mono：0-1个数据

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-50-35-43b84d1bac8df3886bab7388fbc8422d-20231130195034-f55784.png)

# 流的操作

- 类型
	- 创建操作
	- 组合操作
	- 转换操作 
	- 逻辑操作

## 创建Flux

- Flux的静态方法
	- `just`：根据对象创建
	- `fromArray`：根据集成创建，数组、Iterable、Java Stream

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-19-30-099704152461e9b25bdbbf87419d26a9-20231130201930-4b546d.png)

## 组合Flux流

- mergeWith
- zip：自己决定如何合并
- first：取两个流里面最先有的数据

## 过滤Flux流

- skip：指定个数/时间
- take：指定个数/时间
- filter：需要提供Predicate
- distinct：只发布源Flux中尚未发布过的数据项

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-27-9624d81ea1b9b815676419eb53eb71a3-20231130205026-100752.png)

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-36-9648126cc6e148b104e4369205f43c63-20231130205035-0bc08f.png)

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-08-1dc3601d6deecab36c6e8e25231983b3-20231130205008-b20327.png)

## 转换Flux流

### map/flatMap 👍

- map：同步
	- 返回具体值
- **flatMap**：异步
	- 转换出来的**返回结果还是一个流（Mono/Flux）**
	- 为了方便并发处理，放到并发模型里处理
	- 扁平化

- **并发模型（Schedulers方法）**
	- .immediate()
	- .single()
	- .newSingle()
	- .elastic()
	- .parallel()

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-49-26-5285b7a6ede0772dea032de105737181-20231130204925-7ab7ac.png)

### 缓冲

- buffer，缓冲数据，bufferAndFlatMap
- collectList，同：buffer不带参数则缓冲所有数据到列表
- collectMap，需要提供生成key的函数

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F21-01-17-a2c87fea5eefda93fbc122c479c890d2-20231130210117-9de6d6.png)

## 逻辑操作

- all
	- 要提供Predicate函数
	- 所有元素满足条件True
	- 返回`Mono<Boolean>` 
- any
	- 要提供Predicate函数
	- 有元素满足条件返回True
	- 返回`Mono<Boolean>`

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F21-19-03-bb543500e23441c4ac493e1c1cb9e6f4-20231130211902-2aeca5.png)
