# 1.数组
- 特征
	- 相同类型
	- 连续存储
	- 面向实现，不做越界检查（C++允许越界）
## 1.1一维数组
1. 类型定义：`Type name[number]`
2. 元素个数：`sizeof(a)/sizeof(a[0])`
3. 函数接口
- 元素个数需要通过参数**显示**给出，不能用`sizeof`得到(此时`sizeof(a)`转变)
- `void f(int a[],int n)`传参时作为表达式的右值类型自动转换成`int * const &a[0]`,实际上只传了**数组的地址**
- 传参后`a`已经无法得知有多少元素
4. 字符串
	- 字符串都以`\0`结尾
```cpp
char s1[]="abc";  
cout << s1;//实际上是{'a','b','c','\0'}  
char s2[]={'a','b','c'};  
cout << s2;//错误
```
## 1.2一维数组初始化
1. 整数数组初始化
```cpp
//默认初始化  
int a[5] = {}; //[0, 0, 0, 0, 0]  
//全部初始化为0  
int a[5] = {0}; //[0, 0, 0, 0, 0]  
//c++11新写法  
int a[5]{}; //[0, 0, 0, 0, 0]  
  
//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为  
int a[5] = {1}; //[1, 0, 0, 0, 0]  
// 因为 数组初始化列表中的元素个数小于指定的数组长度时， 不足的元素以默认值填补。  
//可以分别赋值  
int a[5] = {1,1,1,1,1}; //[1,1,1,1,1]
```
2. 字符串初始化/栈初始化
```cpp
string *str = string[5]; //调用5次默认构造函数  
string *str1 = string[5]{"aaa"}; //数组中的第一个元素调用 string::string(const char *) 进行初始化。后面四个调用 默认构造函数
```
3. **数组的默认初始化**:如果不明确指出初始化列表，那么基本类型**不会被初始化**(全局变量和静态变量除外)，所有内存都是脏数据；
4. **自定义的类型数组**会为每个元素调用默认构造函数进行初始化
# 1.3一维数组与指针
![6_NVIDIA_GeForce_Overlay_DT.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/01/16/67afba1e6b5e29e46b2bab7c587b70ec_6_NVIDIA_GeForce_Overlay_DT.png)
```cpp
int a[12];
int *p = &a[0];
int *p = a;//a为int *const
//v1
for(int i=0;i<12;i++){
	a[i]=0;
}
//v2
for(int i=0;i<12;i++){
	*(p+i)=0;//等价于*(p++)=0;
}
//v3
for(int i=0;i<12;i++){
	*(a+i)=0;//*(a++)=0错误，因为a的类型是int *const
}
```
# 2.多维数组
1. 定义
```cpp
//1
T A[c1][c2];
//2
typedef T T1[c2]
T1 A[c1]
```

2. 存储形式：数组套数组
3. 参数传递
	- 缺省第1维`void f(int a[][2],int n);`
![7_NVIDIA_GeForce_Overlay_DT.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/01/16/a350293593aa880f67f76360a13c2c15_7_NVIDIA_GeForce_Overlay_DT.png)
