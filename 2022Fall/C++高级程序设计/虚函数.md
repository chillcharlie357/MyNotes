# 虚函数

# 1.类型相容

- 类，类型
- 类型相容，**赋值相容**

## 1.1 对象赋值存在的问题

### 1.1.1直接赋值

- 对象身份发生变化
- 属于派生类的属性不存在

```cpp
A a;
class B:public A;
B b;
a = b//b扩展出的部分丢失
```

**对象切片：**b扩展出的部分会丢失。

原因：`A a = b`会调用`A`的拷贝构造器。

### 	1.1.2 使用指针/引用

- 对象身份未发生变化

```cpp
B* pb;
A* pa=pb;

B b;
A &a = b;
```

# 2.静态绑定/动态绑定

### 静态/前期绑定（Early Binding）

- 编译时刻
- 依据对象的**静态类型**
- 效率高、灵活性差

### 动态/后期绑定（Late Binding）

- 运行时刻
- 依据对象的**实际类型**（动态），根据实际引用和指向对象的类型
- 灵活性高、效率低

出于**效率**考虑，**默认静态绑定**；动态绑定需要用`virtual`关键字显示指出。

# 3.虚函数实现

- 如**基类**中被定义为虚成员函数，则**派生类**中对其重定义的成员函数均为虚函数3.1

## 3.1 限制

1. 类的成员函数**才可以**是虚函数
2. 静态成员函数**不能**是虚函数——在编译期间就确定
3. 内联成员函数**不能**是虚函数——inline在编译时展开
4. 构造函数**不能**是虚函数——构造函数完成才能正常使用虚函数
5. 析构函数**可以（往往）**是虚函数

## 3.2 后期绑定的实现

- 对象的内存空间中含有指针，指向其虚函数表

```cpp
class A {     
    int x,y;
public:
    virtual f();
    virtual g();
    h();
};
class B: public A
{      
    int z;
public:
      f();
      h();
};
A a; B b;
A *p; 
```



![MessageCenterUI_Ql6TXxyqbm](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/img/MessageCenterUI_Ql6TXxyqbm.png)

## 3.3 final,override

# 4.纯虚函数和抽象类

# 5.虚析构函数

