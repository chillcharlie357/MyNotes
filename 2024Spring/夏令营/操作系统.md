---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 操作系统
date:  2024-07-01 13:07
modified:  2024-07-01 17:07
---

> 参考：[计算机与操作系统-06-并发程序设计 | EagleBear2002 的博客](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/)

# 1. 信号量习题

## 1.1. 信号量-前驱关系

|![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/51.png)|![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/52.png)|
|---|---|

```c
semaphore s1 = 0; /*表示进程 P1 是否已经执行完成*/
semaphore s2 = 0; /*表示进程 P2 是否已经执行完成*/
semaphore s3 = 0; /*表示进程 P3 是否已经执行完成*/
semaphore s4 = 0; /*表示进程 P4 是否已经执行完成*/
semaphore s5 = 0; /*表示进程 P5 是否已经执行完成*/
main() {
	cobegin
	P1();
	P2();
	P3();
	P4();
	P5();
	p6();
	coend
}
```

## 1.2. 读者/写者问题

读者与写者问题（reader-writer problem）（Courtois, 1971）也是一个经典的并发程序设计问题。有两组并发进程：读者和写者，共享一个文件 F，要求：

1. 允许**多个读者**可同时对文件执行读操作
2. 只允许**一个写者**往文件中写信息
3. 任意写者在完成写操作之前不允许其他读者或写者工作
4. 写者执行写操作前，应让已有的**写者和读者**全部退出
5. 使用 PV 操作求解该问题

### 1.2.1. (半)读者优先

1. `rmutex` 控制对 `read_count` 的互斥访问；
2. 读者需要对互斥信号量 `rmutex` 进行排队；
3. 只有第一个读者需要对 `wmutex` 排队，后来的读者不需要对 `wmutex` 排队，可以插队到写者前面；
4. 为了保证读时不被打断，读时用 `wmutex` 信号量阻塞写者；当前所有读者读完后，写者才开始写。

> **为什么是半读者优先**？
> 
> W1读取，W2、R2等待。W1读取完毕释放`wmutex`，W2在阻塞队列头，会比R2先获取`wmutex`，无法做到完全读者优先。
> 
> R1读取，W2等待。R1读取完之前R2、R3到达。R1读取完之后不会释放`wmutex`，而是等最后一个读者读完才释放。实现了部分读者优先。

```c
semaphore rmutex = 1; // 控制对 read_count 的互斥访问
semaphore wmutex = 1; // 控制对文件内容的互斥写
int read_count = 0;

process reader_i() {
	while (true) {
		P(rmutex);	// rmutex 用于互斥访问 read_cout
		if (read_count == 0)
			P(wmutex);	// 如果当前是第一个读者，阻塞写者，以保证读到的数据不被更改
		++read_count;
		V(rmutex);

		read();

		P(rmutex);
		if (--read_count == 0)
			V(wmutex);	// 如果当前结束的是最后一个读者，允许开始写
		V(rmutex);
	}
}

process writer_i() {
	while (true) {
		P(wmutex);	// wmutex 用于互斥访问
		write();
		V(wmutex);
	}
}
```

### 1.2.2. 写者优先

1. 后来的写者可以插队到先来的、还未开始读的读者前面；
2. 互斥变量 `z` 保证了每次最多只有一个读者在互斥变量 `rmutex` 排队；
3. “第一个”写者到来时，写者可以立刻对 `rmutex` 排队，且此时最多只有一个读者在 `rmutex` 排队；
4. “后来的”写者到来时，不用对 `rmutex` 排队，直接等前面的写者写完后继续写；
5. “最后一个”写者离开时，开放 `rmutex` 使得读者可以开始读；
6. 写者使用 `rmutex` 阻塞读者。

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/55.png)

### 1.2.3. 读写公平

1. 只比读者优先增加了一个互斥信号量 `S`；
2. 所有读者和写者一起对互斥信号量 `S` 排队，这样后来的读者无法插队到先来的写者前面；
3. 其他性质与读者优先相同。

```c
semaphore rmutex = 1; // 控制对 read_count 的互斥访问
semaphore wmutex = 1; // 控制对文件内容的互斥写
semaphore S = 1; // 控制读写公平的信号量
int read_count = 0;

process reader_i() {
	while (true) {
		P(S);
		P(rmutex);	// rmutex 用于互斥访问 read_count
		if (read_count == 0)
			P(wmutex);	// 如果当前是第一个读者，阻塞写者，以保证读到的数据不被更改
		++read_count;
		V(rmutex);
		V(S);

		read();

		P(rmutex);
		if (--read_count == 0)
			P(wmutex);	// 如果当前没有读者，允许开始写
		V(rmutex);
	}
}

process writer_i() {
	while (true) {
		P(S);
		P(wmutex);	// wmutex 用于互斥访问
		write();
		V(wmutex);
		V(S);
	}
}
```

### 1.2.4. 全读者优先

e.g. W1读取，W2和R1等待，R1可以插队比W2先获得`wmutex`

> **全读者优先怎么实现**？
> 
> W1在写，W2、R1等待。但W2在`rwmutex`队列，R1在`wmutex`队列。W1写完先释放`wmutex`，此时R1获取`wmutex`，开始读；再释放`rwmutex`，W2获取`rwmutex`，然后在`wmutex`的队列等待。
> 
> 后续到达的W3、W4都在`rwmutex`队列等待，最多又一个写者在`wmutex`队列。  
> R1还未读完时，后续如果有新的读者，会一直占有`wmutex`直到所有读者读完。
> 
> 当所有读者读完时，释放`wmutex`，W1才开始写。

```c
semaphore rmutex = 1; // 控制对 read_count 的互斥访问
semaphore wmutex = 1; // 控制对文件内容的互斥写
semaphore rwmutex = 1; // 用于阻塞后来者
int read_count = 0;

process reader_i() {
	while (true) {
		P(rmutex);	// rmutex 用于互斥访问 read_cout
		if (read_count == 0)
			P(wmutex);	// 如果当前是第一个读者，阻塞写者，以保证读到的数据不被更改
		++read_count;
		V(rmutex);

		read();

		P(rmutex);
		if (--read_count == 0)
			V(wmutex);	// 如果当前结束的是最后一个读者，允许开始写
		V(rmutex);
	}
}

process writer_i() {
	while (true) {
		P(rwmutex); // 增加了这一互斥信号量
		P(wmutex);	// wmutex 用于互斥访问
		write();
		V(wmutex);
		V(rwmutex); // 增加了这一互斥信号量
	}
}
```

## 1.3. 睡眠的理发师问题

1. 理发店理有一位理发师、一把理发椅和 n 把供等候理发的顾客坐的椅子
2. 如果没有顾客，理发师便在理发椅上睡觉
3. 一个顾客到来时，它必须叫醒理发师
4. 如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开
5. 使用 PV 操作求解该问题

```c
int waiting = 0;  // 等候理发顾客坐的椅子数
int CHAIRS = N;	  // 为顾客准备的椅子数
semaphore customers, barbers, mutex;
customers = 0;	// customers = 1，当且仅当有顾客可以理发
barbers = 0;	// barber = 1， 当且仅当理发师可以理发
mutex = 1;		// mutex 用于控制对 waiting 的互斥访问
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/57.png)

## 1.4. 农夫猎人问题

有一个铁笼子，每次只能放入一个动物。猎手向笼中放入老虎，农夫向笼中放入羊；动物园等待取笼中的老虎，饭店等待取笼中的羊。请用 P、V 操作原语写出同步执行的程序。

和苹果-桔子问题没有本质区别。

```c
semaphore Scage = 1;
semaphore Stiger = 0;
semaphore Ssheep = 0;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/58.png)

## 1.5. 银行业务问题

某大型银行办理人民币储蓄业务，由 n 个储蓄员负责。每个顾客进入银行后先至取号机取一个号，并且在等待区找到空沙发坐下等着叫号。取号机给出的号码依次递增，并假定有足够多的空沙发容纳顾客。当一个储蓄员空闲下来，就叫下一个号。请用信号量和 P，V 操作正确编写储蓄员进程和顾客进程的程序。

类似苹果-桔子。

```c
semaphore customer_count, server_count, mutex;
customer_count = 0;
server_count = n;
mutex = 1;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/59.png)

## 1.6. 缓冲区管理

有 n 个进程将字符逐个读入到一个容量为 80 的缓冲区中（n>1），当缓冲区满后，由输出进程 Q 负责一次性取走这 80 个字符。这种过程循环往复，请用信号量和 P、V 操作写出 n 个读入进程（P1， P2，…，Pn）和输出进程 Q 能正确工作的动作序列。

生产者消费者问题。

```c
semaphore mutex = 1, empty = 80, full0;
int count = 0, in = 0;
char buffer[80];
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/60.png)

一次性 V 80 次。

## 1.7. 售票问题

汽车司机与售票员之间必须协同工作，一方面只有售票员把车门关好了司机才能开车，因此，售票员关好门应通知司机开车，然后售票员进行售票。另一方面，只有当汽车已经停下，售票员才能开门上下客，故司机停车后应该通知售票员。假定某辆公共汽车上有一名司机与两名售票员，汽车当前正在始发站停车上客，试用信号量与 P、V 操作写出他们的同步算法。

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/61.png)

## 1.8. 吸烟者问题

一个经典同步问题：吸烟者问题（patil，1971）。

三个吸烟者在一个房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴，供应者有丰富货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸和第三个有自己的火柴。供应者随机地将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者**完成吸烟后**唤醒供应者，供应者再把两样东西放在桌子上，唤醒另一个吸烟者。试用信号量和 P、V 操作求解该问题。

> 该代码是在吸烟者完成取物品后、完成吸烟前唤醒供应者，与题意不符，但不影响算法的正确性。

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/62.png)

## 1.9. 独木桥问题

### 1.9.1. 独木桥问题 1

东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。请用信号量和 PV 操作写出过独木桥问题的同步算法。

```c
semaphore wait = 1, mutex1 = 1, mutex2 = 1;
int count1 = 0, count2 = 0;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/63.png)

### 1.9.2. 独木桥问题 2

在独木桥问题 1 中，限制桥面上最多可以有 k 辆汽车通过。试用信号量和 P，V 操作写出过独木桥问题的同步算法。

```c
semaphore wait = 1, mutex1 = 1, mutex2 = 1, bridge = k;
int count1 = 0, count2 = 0;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/64.png)

### 1.9.3. 独木桥问题 3

在独木桥问题 1 中，以 3 辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。试用信号量和 P，V 操作写出汽车过独木桥问题的同步算法。

```c
semaphore wait = 1, mutex1 = 1, mutex2 = 1;
int counter1 = 0, counter2 = 0, counteru1 = 0, countd1 = 0, counteru2 = 0, counterd2 = 0;
semaphore S1 = 3, S2 = 0;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/65.png)

### 1.9.4. 独木桥问题 4

在独木桥问题 1 中，要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。试用信号量和 P，V 操作写出过独木桥问题的同步算法。

```c
semaphore stop = 1, wait = 1, mutex1 = 1, mutex2 = 1;
int count1 = 0, count2 = 0;
```

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/66.png)

# 2. 管程习题

## 2.1. 霍尔管程求解读者/写者问题-写者优先

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/71.png)

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/72.png)

## 2.2. 霍尔管程求解哲学家就餐问题

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/70.png)

|                                                                   |                                                                                                                                                                   |
| ----------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  <br>2  <br>3  <br>4  <br>5  <br>6  <br>7  <br>8  <br>9  <br>10 | ```<br>cobeginprocess philosopher_i() {L:    thinking();    dining_philosopers.pickup(i);    eating();    dining_philosophers.putdown(i);    goto L;}coend<br>``` |

## 2.3. AND 型信号量（课本 188-189 第 53 题）

求解可以使用 AND 型信号量 SP 和 SV 操作

1. `SP(fork[i], fork[(i+1)%5])`
2. `SV(fork[i], fork[(i+1)%5])`

## 2.4. 霍尔管程解决生产者消费者问题

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/73.png)

## 2.5. 霍尔管程求解苹果桔子问题

1. 桌上有一只盘子，每次只能放入一只水果。爸爸专向盘子中放苹果（apple)，妈妈专向盘子中放桔子（orange），一个儿子专等吃盘子中的桔子，一个女儿专等吃盘子里的苹果。使用 Hoare 管程求解该问题
2. SP：盘子
3. SS：桔子
4. SD：苹果

![](https://eaglebear2002.github.io/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/74.png)