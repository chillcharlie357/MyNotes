---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 软件工程
date:  2024-07-03 20:07
modified:  2024-07-03 20:07
---

# 1. 变异测试

变异测试，跟单元测试、集成测试等等东西一样，都属于软件测试技术。**它的核心思想就是随机修改源码，然后运行测试，如果通过则说明你的测试不完善，或者存在多余代码**。

比如这个（本文里的代码都是 TypeScript）：

[![stryker 的报错](https://blog.kaciras.com/image/-yZs3YOOtiH-vVYY5vDY.png?vw=828&vh=126)](https://blog.kaciras.com/image/-yZs3YOOtiH-vVYY5vDY.png?vw=828&vh=126)stryker 的报错

```js

// 对应的测试代码，测试框架 Jest。  
it.each([  
	"\ta;\tb",  
	"a; b;",  
	"a; b\t",  
	"a\t; b",  
])("should split and trim the value %s", value => {  
	expect(split(value)).toStrictEqual(["a", "b"]);  
});
```

这段代码的逻辑是把字符串按`;`分割，去除前后空白并过滤掉空串。在变异测试中，将正则里的一个`\s`改成了大写的`\S`后测试仍然通过，这表明它的代码或测试有问题。

仔细一看就会发现，测试中漏掉了分号旁没有空白的情形，如果给测试数据再加一个`"a;b"`则变异测试不再报错。

当然还有一种做法是改为`value.split(";")`，因为后面已经用`trim`去空白了。

**传统的单元测试，对这种错误是无能为力的，它的覆盖率一直是 100%。** 对此就需要另一种技术，能够对现有的测试进行测试，找出遗漏的用例和多余的代码，这就是变异测试。

## 1.1. 基本理论

变异测试首次在 1971 年提出，最初是为了定位测试单元的弱点。这个理论是：**如果一个变异被引入，同时出现的行为（通常是输出或测试结果）不受影响的话，就说明：变异代码从没有被执行过（产生了无效的代码）或者测试无法定位错误。**

这些变异不是瞎改，而是基于良好定义的操作（变异算子），比如：

- 把`a + b`改为`a - b`。
- 把`a > b`改为`a < b`。
- 把某条`throw new Error()`语句删除。
- 把`if`语句的条件改为`true`或`false`。
- 把某个函数里的代码直接清空。

它不会做一些把关键字`const`改成`cosnt`之类的修改，因为语法检查就能够发现它。

有了变异之后，就开始运行现有的测试，**这也意味着变异测试只能用于已经拥有测试的项目**。在这里每一个变异之后的代码成为一个突变（Mutant），如果它不改变测试的结果就称为存活（Survived）；反之称为杀死（Killed）。

那么被杀死的变体越多，就证明代码写得越好。通过配合覆盖率分析，可以计算出突变分数，作为评判测试质量的指标。

**变异测试通常运行得很慢**，因为一段代码中能替换的地方是非常多的，另外还要通过分析识别出等价的组合。而且对于每个突变，都要找到覆盖到它的测试并运行。

## 1.2. 更多示例

[![多余的初始化](https://blog.kaciras.com/image/qtlD5kuS-mV7H_c62qs-.png?vw=728&vh=299)](https://blog.kaciras.com/image/qtlD5kuS-mV7H_c62qs-.png?vw=728&vh=299)多余的初始化

这个数组的初始值与构造函数里的重复了，属于多余代码，变异测试通过更改数组中的元素发现了这个问题。

[![相似函数调换](https://blog.kaciras.com/image/RJm6QHioRTHHrkqxWXvA.png?vw=810&vh=201)](https://blog.kaciras.com/image/RJm6QHioRTHHrkqxWXvA.png?vw=810&vh=201)相似函数调换

这个是测试写得不完善，忘了断言最终结果的行数，导致`#`开头的行有没有被排除都一样。

## 1.3. 无效的情况

由于程序本身是复杂的，同时突变也不会深入到第三方代码，**所以突变测试即使报告了存活，也并不意味着有错误，必须具体分析**。我的项目中也有一些例子：

[![字符串替换](https://blog.kaciras.com/image/_46v89l2gNqeeM6sD6Jd.png?vw=606&vh=150)](https://blog.kaciras.com/image/_46v89l2gNqeeM6sD6Jd.png?vw=606&vh=150)

字符串替换

这是个读取 JSON 文件的函数，因为 `JSON.parse` 对非字符串类型会调用`toString`，所以去掉`"uft8"`传递 Buffer 也正确。

但提前指定编码更好，这样能在读取到缓冲区后就解码，避免创建完整的 Buffer，所以这段代码是正确的，该变异可以忽略。

还有一类误报的情况就是防御性编程，例如下面的：

[![正则替换](https://blog.kaciras.com/image/LkgXSoNQBJswzp-SfBQu.png?vw=845&vh=175)](https://blog.kaciras.com/image/LkgXSoNQBJswzp-SfBQu.png?vw=845&vh=175)正则替换

这段代码的作用是解析爬虫下载的文件，按行分割并作一些处理。在分割时，使用`\n`遇到连续的空行会生成空白元素，而`\n+`则不会。虽然目前抓取的文件没有这种情况，导致变异存活，但保不准未来会遇到，所以这个变异也不用管。

## 1.4. 变异测试理论

变异测试是一种 fault-based 的软件测试技术。这项技术已经广泛研究并使用了三十余年。它为软件测试贡献了一系列方法，工具，和可靠的结果。本文将对变异测试进行深入的调查，分析它的优势和不足之处，并对比几种不同的变异测试方法，提出一些改进的建议。

　　下面用一个例子来解释什么是变异测试，考虑以下代码片段：

```c
　　if(a && b) c = 1;
　　else c = 0;
```

条件运算符如果用||来替换&&，就会产生以下变异：

```c
　　if(a || b) c = 1;
 　　else c = 0;
```

- 为了杀死这个突变，需要满足以下条件：
	1. 测试数据必须对突变和原始程序引起的不同状态覆盖。如：a=1,b=0可以达到目的。
	2. c的值应该传播到程序输出，并被测试检查。

弱突变覆盖需满足（1），强突变覆盖需满足（1）（2）。

下面进行正式的内容。

### 1.4.1. 变异测试理论

#### 1.4.1.1. 两个基本假设

　　变异测试旨在找出有效的测试用例，发现程序中真正的错误。在一个工程中，潜在BUG的数量是巨大的，通过生成突变体来全面覆盖所有的错误是不可能的。所以，传统的变异测试旨在寻找这些错误的子集，能尽量充分地近似描述这些BUG。这个理论基于两条假设：Competent Programmer Hypothesis(CPH) 和 Coupling Effect(CE)。

　　CPH是指：假设编程人员是有能力的，他们尽力去更好地开发程序，达到正确可行的结果，而不是搞破坏。它关注的是程序员的行为和意图。而CE(耦合效应)更加关注在变异测试中错误的类别。一个简单的错误产生往往是由于一个单一的变异（例如句法错误），而一个庞大复杂的错误往往是由于多出变异所导致。复杂变异体往往是由诸多简单变异体组合而成。

#### 1.4.1.2. 变异测试流程

 ![](https://images0.cnblogs.com/blog2015/757593/201505/271335490794607.png)

 　　在变异测试中，对于被测程序p，设定一个测试用例集合T。首先根据被测程序特征设定一系列变异算子；随后通过在原有程序p上，执行变异算子生成大量变异体；接着从大量变异体中识别出等价变异体；然后在剩余的非等价变异体上执行测试用例集T中的测试用例，若可以检测出所有非等价变异体，则变异测试分析结束，否则对未检测出的变异体，需要额外设计新的测试用例，并添加到测试用例集T中。

　　基于上述传统变异测试分析流程， 对其中的基本概念依次定义如下。

　　**定义 1**（变异算子） 在符合语法规则前提下， 变异算子定义了从原有程序生成差别极小程序（即变异体） 的转换规则。表 1给出了一个典型的变异算子， 该变异算子将“＋” 操作符变异为 “-” 操作符。选择被测程序 p 中的条件表达式 a + b > c 执行该变异算子， 将得到条件表达式 a - b > c ， 并生成变异体 p′ 。  
![](https://images0.cnblogs.com/blog2015/757593/201505/271555300163097.png)

　　Offutt和King在已有研究工作的基础上，于 1987年针对 Fortran77首次定义了 22种变异算子，这些变异算子的简称和描述如表 2 所示。

![](https://images0.cnblogs.com/blog2015/757593/201505/271559347984979.png)

　　这22种变异算子的设定为随后其他编程语言变异算子的设定提供了重要的指导依据。在完成变异算子设计后，通过在原有被测程序上执行变异算子可以生成大量变异体_M_，在变异测试中，变异体一般被视为含缺陷程序。根据执行变异算子的次数，可以将变异体分为一阶变异体和高阶变异体，并分别定义如下。

　　**定义 2** （一阶变异体） 在原有程序 _p_ 上执行单一变异算子并形成变异体 _p_′ ，则称_p_′为_p_的一阶变异体。

　　**定义 3** （高阶变异体） 在原有程序 p 上依次执行多次变异算子并形成变异体 p′ ，则称 p′ 为 p 的高阶变异体。若在 p 上依次执行 k 次变异算子并形成变异体 p′ ， 则称 p′ 为 p 的 k 阶变异体。

**高阶变异体实例**

![](https://images0.cnblogs.com/blog2015/757593/201506/240926334391082.png)

　　**定义 4** （可杀除变异体）若存在测试用例 _t_，在变异体 _p_′ 和原有程序 _p_ 上的执行结果不一致， 则称该变异体 _p_′ 相对于测试用例集 _T_ 是可杀除变异体。

　　**定义 5**（可存活变异体） 若不存在任何测试用例_t_ ， 在变异体 _p_′ 和原有程序 _p_ 上的执行结果不一致， 则称该变异体 _p_′ 相对于测试用例集 _T_ 是可存活变异体。一部分可存活变异体通过设计新的测试用例可以转化成可杀除变异体， 剩余的可存活变异体则可能是等价变异体。本文对等价变异体定义如下。

　　**定义 6** （等价变异体）若变异体 _p_′ 与原有程序 _p_ 在语法上存在差异， 但在语义上与 _p_ 保持一致， 则称_p_′ 是 _p_ 的等价变异体。

**等价变异体实例**

![](https://images0.cnblogs.com/blog2015/757593/201506/240928592836459.png)

### 1.4.2. 等价变异体检测

　　等价变异体检测是一个不可判定问题，因此需要测试人员借助手工方式予以完成。等价变异体在语法层次上有微小的差别，但是在语义层次上是一致的。有研究人员发现，在生成的大量变异体中，等价变异体所占比例一般介于10%~40%。在等价变异体的检测上，主要有两类方法。

#### 1.4.2.1. 等价变异体静态检测法_

该方法基于如下猜测：源代码在编译时借助优化规则可以生成语义等价代码。

#### 1.4.2.2. 等价变异体动态检测法

　　Adamopoulos 等人提出一种基于遗传算法的协作演化法（即测试用例和变异体同时进行演化）来检测可能的等价变异体。他们通过设置合理的适应值函数， 确保当变异体是等价变异体时， 该函数可以返回一个很小的适应值。基于该适应值函数， 群体在演化过程中可以有效淘汰部分等价变异体， 同时将那些难以检测的变异体和检测能力强的测试用例均保留下来。

### 1.4.3. 变异体选择优化

　　变异体选择优化策略主要关注如何从生成的大量变异体中选择出典型变异体。

### 1.4.4. 随机选择法

　　随机选择法尝试从生成的大量变异体中随机选择出部分变异体。具体来说， 首先通过执行变异算子生成大量变异体 _M_ ； 然后定义选择比例 _x_ ； 最后从变异体 _M_ 中随机选择出 |_M_| ´ _x_% 的变异体， 剩余未被选择的变异体则被丢弃。

### 1.4.5. 聚类选择法

　　具体来说， 首先对被测程序_p_ 应用变异算子生成所有的一阶变异体； 然后选择某一聚类算法根据测试用例的检测能力对所有变异体进行聚类分析， 使得每个聚类内的变异体可以被相似测试用例检测到； 最后从每个聚类中选择出典型变异体， 而其他变异体则被丢弃。

### 1.4.6. 变异算子选择法

　　与上述两类方法不同， 这类方法从变异算子选择角度出发， 希望在不影响变异评分的前提下， 通过对变异算子进行约简来大规模缩小变异体数量， 从而减小变异测试和分析开销。结果表明， 变异算子选择法相对于随机选择法来说并不存在明显优势， 随机选择法值得研究人员继续深入研究。

### 1.4.7. 高阶变异体优化法

　　高阶变异体优化法基于如下推测：（1）执行一个_k_ 阶变异体相当于一次执行 _k_ 个一阶变异体；（2） 高阶变异体中等价变异体的出现概率较小。实证研究表明， 采用二阶变异体可以有效减少50%的测试开销， 但却不会显著降低测  
试的有效性。

## 1.5. 结束语

　　变异测试作为一种面向软件缺陷的测试技术，得到国内外研究人员的关注， 并取得了大量研究成果。本文从变异测试原理、 优化和应用 3个角度对已有的研究工作进行了系统总结。虽然目前针对变异测试的研究已经取得了大量  
的成果， 但该领域仍存在很多研究点值得关注。可以考虑的研究点包括：

（1）变异测试中仍存在大量开放性问题。例如等价体变异检测问题， 已有研究工作主要集中于从生成的变异体中识别出等价变异体。在将来的研究工作中可以考虑通过设计变异算子和分析被测程序特征， 提出有效策略， 在变异体生成过程中避免等价变异体的生成。

（2）在变异测试分析优化中， 即变异体的生成、编译和执行过程中存在很多研究点。例如， 在变异算子选择中可以考虑将变异算子按照变异体检测能力进行排序； 借助硬件的发展和多核 CPU的广泛使用， 深入研究并行变异测试等。

（3）重点关注面向变异测试的测试用例生成技术。已有研究工作大部分关注于变异体的生成技术， 但面向变异测试的测试用例生成研究还在起步阶段， 并亟需成熟工具进行支持。可以进一步考虑将动态符号执行法和 SBST进行有效组合， 以提高测试用例的生成效率。

（4）进一步考虑变异测试研究成果与工业界测试流程的结合。目前的研究一般采用对照试验方式进行有效性评估， 所得结论很难适用于软件企业的大型软件产品。其次研究人员提供的原型工具并未考虑与软件企业目前已有的开发和测试流程紧密结合， 若要让企业接受学术界的研究成果， 需要进一步提高测试工具的自动化程度， 改善工具用户界面， 并提高工具的鲁棒性。

# 2. Profiling技术

在软件工程中，性能分析（performance analysis也称为profiling），是以收集程序运行时信息为手段研究程序行为的分析方法，是一种动态程序分析的方法。  
性能分析量测像是程序的空间或时间复杂度、特定指令的使用情形、函数调用的频率及执行时间等。性能分析的目的在于决定程序的哪个部分应该被优化，从而提高程序的速度或者内存使用效率。  
性能分析可以由程序的源代码或是可执行档进行。一般会使用称为性能分析工具（profiler）的工具进行。性能分析工具会使用许多不同的技术，可能是以事件为基础（Event-based）的、统计的、指令导向的、仿真的方法。性能分析工具常用在性能工程的过程中。

> profiling技术在单语言效果好，但是多语言效果不好的原因？

在单语言环境下，Profiling技术可以针对特定语言的运行时环境和特性进行优化，因此效果较好。然而，在多语言环境中，由于涉及到不同语言的运行时环境、内存管理、垃圾回收机制等差异，Profiling技术可能面临以下挑战，导致效果不佳：

1. **运行时环境差异**：不同的编程语言可能有不同的运行时环境和执行模型，例如Java的JVM和.NET的CLR，这些环境对性能数据的收集和分析有不同的影响。
2. **性能数据收集的复杂性**：多语言环境下，需要收集和分析来自不同语言的性能数据，这增加了数据收集和整合的复杂性。
3. **资源竞争和调度问题**：在多语言环境中，不同语言编写的组件可能在共享资源（如CPU、内存）上存在竞争，这可能会影响性能分析的准确性。
4. **语言特性和优化策略**：每种编程语言都有自己的特性和优化策略，Profiling工具需要对每种语言的这些特性有深入的理解才能有效工作。
5. **工具和方法的局限性**：某些Profiling技术和工具可能只针对特定语言或平台优化，当应用于多语言环境时，可能无法充分利用每种语言的特性，导致性能分析的效果不佳。
6. **性能瓶颈的识别难度**：在多语言环境中，性能瓶颈可能更难识别，因为不同语言的组件可能在不同的层次上交互，增加了分析的难度。
7. **持续性能分析的挑战**：Continuous Profiling（持续性能分析）在多语言环境中实施可能面临更多挑战，因为它需要在整个应用的生命周期中持续收集和分析数据，而不同语言和平台的集成可能会增加这一过程的复杂性。
8. **性能分析工具的Overhead问题**：在多语言环境中，Profiling工具可能会引入额外的性能开销（Overhead），尤其是在资源受限的生产环境中，这可能会影响应用的性能。