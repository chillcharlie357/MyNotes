---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 09_关系数据理论 1
date:  2024-07-02 15:07
modified:  2024-07-02 16:07
---

# 1. 关系模式

- 关系模式：形如$R(U,D,DOM,F)$的五元组
	- R关系名
	- U为属性组，关系模式的属性集合
	- D为属性组U中属性来自的域
	- DOM属性像域的映像集合
	- F数据依赖

关系：每个属性不可再分隔

# 2. 数据依赖

关系内部属性和属性之间的约束关系，通过属性间值的是否**相等**体现。体现语义。

包含：  
函数依赖  
多值依赖

# 3. 函数依赖

是一种数据依赖。  
在现实中广泛存在，只能作为<font color="#ff0000">语义</font>的一部分来自需求分析。

- **函数依赖**：$R(U)$是属性集U上的关系模式，X、Y是U的子集。若对于$R(U)$的任意一个可能关系r，r中不可能存在两个元组**在X上属性值相等，在Y上不等**，则**Y函数依赖于X**，记作$X\rightarrow Y$
	- 其中X为**决定因素**
	- 类似函数定义域映射到值域，每个X都唯一确定一个Y。

- 非平凡函数依赖：$X\rightarrow Y  and Y\not\subseteq X$ 
	- 否则为平凡函数依赖
- 传递函数依赖：$X\rightarrow Y(Y\not\subseteq X) , Y\not\rightarrow X, Y\rightarrow Z(Z\not\subseteq Y)$则Z对X是传递函数依赖，记为$X\stackrel{传递}{\rightarrow}Z$

- **完全函数依赖**：$X \rightarrow Y and X^`\not\rightarrow Y, X^`\subset X$ ，则Y对X完全函数依赖。$X\stackrel{F}{\rightarrow}Y$
	- 解释：取$X$的子集可能会导致在X上属性相等，在Y上不相等。
	- 否则$X\stackrel{P}{\rightarrow}Y$，部分函数依赖

# 4. 码

[[04_关系代数]]

- 候选码：**属性或属性组**$K\in R<U,F>$，如果$K\stackrel{F}{\rightarrow}U$则K为R的候选码
	- 解释：唯一确定元组的最小属性组。
- 超码：$K\stackrel{P}{\rightarrow}U$
	- 可以唯一确定元组，但不是最小的属性组。

候选码是最小的超码，即候选码的任意真子集都不是候选码。

- 主码：在多个候选码中选定一个。
- 主属性：包含在候选码中的属性。
- 外码：属性不是本关系模式的码，但是另一个关系模式的码。

## 4.1. 计算

FD : function dependency

1.**只在FD右部**出现的属性,不属于候选码;  
2.**只在FD左部**出现的属性,一定存在于任何候选码当中;  
3.**两边均不出现**的属性一定存在于任何候选码当中;  
4.**其他属性**逐个与一定在候选码中的属性组合,求**属性集闭包**,直至X的闭包等于U，若等于U，则X为候选码。（如果2、3得到的集合X被证明已经是候选码，所以就不用继续4步骤）

**属性集闭包**：先列出属性集的非空子集，然后写出相应的函数依赖，求交集，闭包运算

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F07%2F02%2F16-03-46-4f337a833ece2c24c86df2c75ff88d3f-20240702160346-a66987.png)

# 5. 范式👍

- 关系数据库中的关系要满足一定的要求
- **规范化**（normalization）：低一级分关系模式通过**模式分解**可以转换为若干个高一级的关系模式的集合。
- 各个范式关系：

$$
5NF \subset 4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF
$$

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/13/c66f26888c8e0107ade7d29290037c97_202304131736585.png)  
2NF,3NF可以画图判断；BCNF看决定属性集是否都包含候选码。

## 5.1. 1NF

- 1NF第一范式，满足最低要求
- 条件：每个分量都是不可分割的数据项。

函数依赖关系：当前关系型上满足的约束

- 主属性：
	- 包含在任意一个候选码中的属性
	- 反映共性
- 非主属性：反映个性
- 全码：整个属性组是码，称为全码
- 外码：关系的属性是另外一个关系的主码

## 5.2. 2NF

- $R\in 1NF$，每一个**非主属性**都是**完全函数依赖**于任何一个候选码，则$R\in 2NF$
	- 消除了非主属性对码的部分函数依赖

### 5.2.1. 例子

![NVIDIA_Share_729_772.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/26/398cc56b7667b6b08c7d8e5d091e1783_NVIDIA_Share_729_772.png)

![NVIDIA_Share_938_472.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/26/ddce5b761bb2efd7e60bf66046791786_NVIDIA_Share_938_472.png)  
sloc为学生宿舍  
cno-class  
sno-student

#### 5.2.1.1. 问题

一个好的关系模式应该不发生插入异常、删除异常和更新异常，数据冗余也应该尽量少。

- 数据冗余
	- 上图Student表中，系主任的名字反复出现，重复次数与该系所有学生的课程成绩出现次数相同。
	- 造成大量空间浪费。
- 更新异常
	- 如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。
	- 由于数据冗余，在更新数据库时，系统代价很大，否则会不一致。
- 插入异常
	- 如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。
- 删除异常
	- 如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。

#### 5.2.1.2. 解决

- 例子中有两类非主属性：
	- 一类如Grade，它对码完全函数依赖
	- 另一类如Sdept、Sloc，它们对码不是完全函数依赖

使用投影把原来的关系模式分解成两个  
SC(Sno,Cno,Grade)  
S-L(Sno,Sdept,Sloc)

![NVIDIA_Share_814_187.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/26/7f030b01e5bc1aac97035d0c3aba7e68_NVIDIA_Share_814_187.png)

但插入异常、删除异常仍然存在。

## 5.3. 3NF

- 设关系模式R<U,F>∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊉Y）, 使得X→Y，Y→Z成立，Y ↛ X不成立，则称R<U,F> ∈ 3NF。
	- 消除了非主属性对码的**传递依赖**

- 上例关系模式SL还有传递依赖，所以不是3NF，分解：
	- S-D(Sno,Sdept)∈ 3NF
	- D-L(Sdept,Sloc)∈ 3NF

![NVIDIA_Share_319_343.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/26/432ad74981a7ac7bb6bc9207a8155336_NVIDIA_Share_319_343.png)

### 5.3.1. 存在问题

还是没有消除了插入异常和删除异常。

## 5.4. BCNF

扩充第三范式

- 设关系模式R<U,F>∈1NF，若X →Y且Y ⊈ X时X必含有码，则R<U,F>∈BCNF。
	- 即在关系模式R<U,F>中，如果<font color="#ff0000">每一个决定属性集都包含候选码</font>，则R∈BCNF。
	- 消除了任何属性对码的传递依赖和部分依赖

消除了插入异常和删除异常。

### 5.4.1. 性质

- 所有非主属性都完全函数依赖于每个候选码
- 所有主属性都完全函数依赖于每个不包含它的候选码
- 没有任何属性完全函数依赖于非码的任何一组属性

