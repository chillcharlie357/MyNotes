---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 03-索引结构、实现及使用
date:  2024-03-11 14:03
modified:  2024-03-13 11:03
---

# 1. 索引

- 索引：是一种排序的数据结构，协助快速查询、更新数据库表中的数据
	- B+ Tree
	- 基于磁盘存储，堆文件/随机文件

- 目标
	1. 高扇出：改善邻近键的数据局限性(每个块的节点尽量多)
	2. 低高度：减少遍历期间的寻道次数

# 2. 👍B Tree/B+Tree结构

- B+ Tree
	1. 内部节点只存key，不存value
	2. <span style="background:rgba(3, 135, 102, 0.2)">叶节点才存value</span> （和B Tree的主要区别）
	3. 相邻叶节点之间有指针->为了方便范围查询
- 每个节点刚好放在一个块里（硬盘存储最小单元）
- 占用率：节点容量和实际持有键的数量之间的关系
	- 一般是50%
	- 如果太紧凑，不利于写，一旦增加都需要大幅修改树的结构

- 为什么不用BST：适合内存搜索，但不适合磁盘搜索

# 3. B树查找算法

- 算法复杂度从两个角度讨论：**块传输**，**键比较**

- 块传输：
	- 块传输数量等于树高H
- 比较次数：对数基数为2，二分查找，每次比较，搜索空间减半，复杂度为logM

- B+Tree 块数量的设计
	- 内部节点: key和指针  
	- 叶节点: key,value和指针
	- 数量不能确定

# 4. 👍B树的分裂

插入节点，可能导致分裂

- 叶节点分裂：把value复制到下一块
	1. 先以叶节点中心分裂
	2. 构建上层节点
	3. 插入，改变link
- 非叶节点分裂：直接把Key分割点放到上层
	1. 创造新节点
	2. 把原节点**N/2 + 1**移到下一节点

保证50%占用率

# 5. 👍B树的合并

删除节点，可能导致合并

- 节点最大容量N个key-value，N+1个指针
	- 叶节点：key-value的数量是否小于N，把上面的key删除  
	- 非叶节点：指针数量是否小于N+1，把上面的key下移

- <span style="background:rgba(3, 135, 102, 0.2)">问题：分裂合并导致IO过于频繁</span>
	- 不同公司在分裂时一致，但合并有不同优化策略
- 解决思路：
	1. 按照存储空间的占比设置阈值，而不是key-value/指针的数量
	2. 再平衡，控制平衡的个数

# 6. B树索引能做什么

1. 全键值 WHERE x=123
2. 键值范围 WHERE 45 < x <232
3. 键前缀查找 WHERE x LIKE 'J%'

除了这三个，其他查询都用不上B树索引。

# 7. 索引结构

T(**id**,b,**c**,d)

1. 二级索引直接指向数据不使用主索引
	- 对读有利
2. 二级索引指向主索引
	- 对写有利，发生修改时只需要修改主索引
	- 读效率低

# 8. 索引的问题

## 8.1. 开销

1. 磁盘开销
	- 基本表可能只占存储空间的小部分，大部分是索引
2. 处理的开销
	- 插入数据也要同时插入索引，会导致合并和删除，过多的索引导致插入速度过慢
	- 索引本身也有锁

## 8.2. 压缩

1. 主要针对叶节点的value压缩，key值很难压缩
2. 一般是对复合键索引压缩

## 8.3. 索引会降低查询效率吗

有可能，如果表很小可能全表查询的效率比索引高

- 索引和目录
	- 两种完全不同的机制
	- 索引是一种以原子粒度访问数据库的手段而不是为了检索大量数据的

