---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 06-数据库设计（一致性保障）
date:  2024-04-22 14:04
modified:  2024-05-06 15:05
---

# 1. 数据库范式

1. 1NF：属性的原子性  
2. 2NF：属性的主键完全依赖  
3. 3NF：不存在传递函数依赖  
	- 冗余最小化
4. BCNF、4NF、5NF（完美范式）

# 2. 数据库反范式

规范化的结果是一个结构上一致，且拥有最小冗余的结构，但未必是性能最优的设计。

- 反范式本质是——考虑引入可控制的冗余
	1. 实现更复杂，需要手动控制冗余
	2. 减低灵活性
	3. **加快读取**，降低更新
- 主要动作：**复制**
- <font color="#c00000">核心目标</font>：**减低连接次数**，提高查询效率

# 3. 数据库反范式模式

1. 合并1:1关系
2. 复制1:\*关系的非Key、FK及值
3. 复制\*:\*关系的属性
4. 引入重复组
5. 创建提取临时表

## 3.1. 合并1:1关系

部分参与会大量引入空值，处理复杂

## 3.2. 复制1:\*关系的非Key、FK及值

多代码表的连接基本上都是通过**复制代码值**，而不是外键id，来减少表连接

适用于，代码表的值比较固定，值的数量不多

## 3.3. 复制\*:\*关系的属性

## 3.4. 引入重复组

4NF要求

- 地址，电话
- 静态，数量小

e.g.：淘宝，选择收获地址，在customer主表里加一列常用地址。当用户点击更多地址时，才查询用户的全部地址。

## 3.5. 创建提取临时表

静态，时间切片，不是实时数据  
实时计算，物化视图，代价极大  
不推荐

# 4. 数据库设计

基本满足3NF，可能产生多种设计结果

## 4.1. 树状结构

对象类型相同，而对象的层次可变，其关系就应该被建模为树结构

树状结构复杂度在于：树的访问

- 实际实现：
	1. 邻接模型
	2. 物化路径模型
	3. 嵌套集合模型

### 4.1.1. 临接模型

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-34-38-06846e7ba7d8cee19acef8e6c934d650-20240506143438-c20582.png)

满足单父节点

- T(id,pid,attr...)
	- id标记当前节点，pid标记父节点
- 问题：
	1. 会丢失子节点的顺序
	2. **不符合归一化原则（一事，一地，一次）**，无法通过数据库保证一致性
		- pid存在多处修改也需要多次
		- insert时数据库无法检查是否是有圈，无法检查是树而不是图，需要再应用系统检查
		- delete复杂
	3. 要找所有子节点很复杂

### 4.1.2. 物化路径模型

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-33-53-c3e2181ff81f828c5e79ba5b6a54a2ad-20240506143352-43562c.png)

- T(m_path,attr...)把路径存成一个字段


1. 解决了子节点顺序问题
2. insert时更容易控制
3. 找所有子节点简单，只需要字符串匹配
4. 无法满足归一化，父节点路径存在多个子节点里，发生修改还是要多次修改
5. 不容易变成图
6. delete数据还是要手动处理

路径id是字符串，处理性能差
读写性能最平衡
### 4.1.3. 嵌套集合模型

T(left_num,right_num,attr...)，基于集合论，在[left,num]内的都是该节点的子节点

1. 可以保存子节点顺序
2. delete节点，可以自动缺省处理
3. **insert要修改很多，所有右边的节点都要改**
4. 是归一化模型

现实里使用往往更新比较少，而且保留range

### 4.1.4. 闭包表模型


![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F08%2F10-34-24-6ea9584f1a11e2c1867bdc5693f26d17-20240508103424-84e55e.png)

- 整棵树在两张表里记录，节点表和节点关系表。
- NodeRelation(id, ancester, descendant, distance)，定义了所有节点之间的关系

闭包模型不仅可以处理树也可以处理图，可读性更差，通用性和扩展性强


场景：论坛回帖，典型的树状结构

## 4.2. 查询

### 自顶向下
查询所有子节点，缩进排序

1. 邻接模型
	1. oracle的connect by,mysql递归查询
	2. 手动union，在一个查询中多次连接，前提是知道深度
	3. 单独设计一张关系表，T(id,pid,distance)，保存节点到所有父节点的距离
2. 物化路径模型
	1. 字符串前缀比较，深度就是`.`的个数
3. 嵌套集合模型
	1. 遍历整张表，只要在[left,right]内，一定是子节点。但是缩排很复杂。


效率指标： t/s，每秒做了几个事务，兼顾容量和时间

资源消耗：from表连接>字符串处理>数值比较


### 自底向上查询

1. 邻接模型

# 5. 递归SQL语法



```sql

WITH RECURSIVE cte_name (column_list) AS (
//初始查询

//递归查询
)
//主查询
SELECT ...
FROM cte_name
WHERE ...
```


引入层次

