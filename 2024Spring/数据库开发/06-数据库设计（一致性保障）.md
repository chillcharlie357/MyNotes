---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 06-数据库设计（一致性保障）
date:  2024-04-22 14:04
modified:  2024-04-22 14:04
---

# 1. 数据库范式

1. 1NF：属性的原子性  
2. 2NF：属性的主键完全依赖  
3. 3NF：不存在传递函数依赖  
	- 冗余最小化
4. BCNF、4NF、5NF（完美范式）

# 2. 数据库反范式

规范化的结果是一个结构上一致，且拥有最小冗余的结构，但未必是性能最优的设计。

- 反范式本质是——考虑引入可控制的冗余
	1. 实现更复杂，需要手动控制冗余
	2. 减低灵活性
	3. **加快读取**，降低更新
- 主要动作：**复制**
- <font color="#c00000">核心目标</font>：**减低连接次数**，提高查询效率

# 3. 数据库反范式模式

1. 合并1:1关系
2. 复制1:\*关系的非Key、FK及值
3. 复制\*:\*关系的属性
4. 引入重复组
5. 创建提取临时表

## 3.1. 合并1:1关系

部分参与会大量引入空值，处理复杂


## 3.2. 复制1:\*关系的非Key、FK及值


多代码表的连接基本上都是通过**复制代码值**，而不是外键id，来减少表连接

适用于，代码表的值比较固定，值的数量不多

## 3.3. 复制\*:\*关系的属性


## 3.4. 引入重复组


4NF要求

- 地址，电话
- 静态，数量小

e.g.：淘宝，选择收获地址，在customer主表里加一列常用地址。当用户点击更多地址时，才查询用户的全部地址。

## 3.5. 创建提取临时表

静态，时间切片，不是实时数据
实时计算，物化视图，代价极大
不推荐


# 4. 数据库设计

基本满足3NF，可能产生多种设计结果

## 4.1. 树状结构

对象类型相同，而对象的层次可变，其关系就应该被建模为树结构

树状结构复杂度在于：树的访问

- 实际实现：
	1. 邻接模型
	2. 物化路径模型
	3. 嵌套集合模型

### 4.1.1. 临接模型

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-34-38-06846e7ba7d8cee19acef8e6c934d650-20240506143438-c20582.png)


满足单父节点

- T(id,pid,attr...)
	- id标记当前节点，pid标记父节点
- 问题：
	1. 会丢失子节点的顺序
	2. **不符合归一化原则（一事，一地，一次）**
		- pid存在多处修改也需要多次
		- insert时数据库无法检查是否是有圈，无法检查是树而不是图，需要再应用系统检查
		- delete复杂
	3. 要找所有子节点很复杂





### 4.1.2. 物化路径模型

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-33-53-c3e2181ff81f828c5e79ba5b6a54a2ad-20240506143352-43562c.png)


- T(m_path,attr...)把路径存成一个字段

1. 解决了子节点顺序问题
2. insert时更容易控制
3. 找所有子节点简单，只需要字符串匹配
4. 无法满足归一化，父节点路径存在多个子节点里，发生修改还是要多次修改
5. delete数据还是要手动处理

### 4.1.3. 嵌套集合模型


T(left_num,right_num,attr...)，基于集合论，在[left,num]内的都是该节点的子节点

1. 可以保存子节点顺序
2. delete节点，可以自动缺省处理
3. insert要修改很多，所有右边的节点都要改
4. 是归一化模型

### 4.1.4. 查询

- 查询所有子节点
	1. 如果知道层数，可以自连接
	2. 