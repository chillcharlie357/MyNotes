---
aliases: 
tags: 
categories: 
sticky: 
thumbnail: 
cover: 
excerpt: false
mathjax: true
comment: true
title: 05-事务
date:  2024-04-08 14:04
modified:  2024-04-15 14:04
---

# 1. 事务处理

1. A 原子性：事务本质要求
2. C 一致性：数据完整要求，开发者控制而不是数据库控制
	1. 数据库只能保证实体完整性和参照完整性，数据的一致性只能由开发者保证
3. I 隔离性：并发的要求
4. D 持久性：数据库系统要求

事务调度管理器  
锁管理器：保证隔离性，锁的粒度决定隔离级别  
页缓存：充当持久化存储和存储引擎其余部分之间的中介  
日志管理器  
分布式事务协调

# 2. 缓冲区管理 Buffer Management

1. 双层存储是大部分数据库的基础
2. **页缓存**
	1. Page in 换入
	2. Flush 刷写
	3. Evict 换出

> 缓存页什么时候换出？
> 提早换出，还是刷写时才换出？

## 2.1. 在缓存中锁定页

1. B+树越靠近顶部越窄，层次较高的节点在大多数读取中都会被命中
2. 分裂和合并操作最终会传播到高层节点
3. 频繁的子树结构变化，可以一起处理

## 2.2. 页置换策略选择

缓存更大不能减少换出次数，Beadly异常

1. FIFO
2. LRU：最长时间未使用策略
	1. 范围查询时，连续查询叶节点，叶节点虽然只被读一次但会把根节点换出去
3. LRU-K：最近K次访问频繁用到的页，并使用此信息估计访问时间
4. 2Q的LRU（双队列，k=2）：后续访问移入第二个队列，从而区分最近访问和经常访问
5. LFU
6. CLOCK



# 恢复

- 日志：**恢复最重要的技术**
	1. Undo
	2. Redo：事务提交后，数据库发生崩溃，还未写回到磁盘
		- 格式e.g.把#1表的#293页面的偏移量2323的值更新为2


- 为什么不在事务提交之前，把事务所有的页面刷写到磁盘？
	1. 刷写一个完整的数据页太浪费，如果只修改一个字节，却要刷写一个16k的数据页
	2. 随机I/O环境效率低


## redo日志设计


- Redo
	1. 占用空间小，
	2. 顺序I/O


- 静态结构
	1. redo目录的结构
	2. redo需不需要设置页大小？要不要比正常的page大？
		1. 页要足够大，方便一次性全部读出来
	3. 顺序文件还是随机文件？
		1. 顺序I/O，追加写
- 动态结构
	1. 事务的原子性如何保障？冲突如何解决？
	2. redo日志也是双存储结构，如何写？
- 维护
	1. 如何循环使用redo

### 格式

- 本质是记录事务对数据库物理表上的修改

- 简单日志：
	1. Type
	2. SpaceID：表ID
	3. Page number：页ID
	4. Data
	5. offset
	6. len：可能是变长
- 复杂日志：一条SQL可能修改多个地方（数据页面，聚簇索引，二级索引等）
	1. 在每个修改的地方都记录一条日志
		- 导致有很多条日志
	2. 将整个页面第一个修改的字节到最后一个修改的字节之间的数据，当成一条物理redo
		- 只有一条日志，但是很大


- 其他可能：只记录操作，不记录物理变化
	1. 物理层面的记录：指明哪个表空间，哪个页被改动
	2. 逻辑层面的记录：记录操作，系统崩溃后，重新执行这个操作
		- 基于逻辑的日志：本质是提供了调用恢复函数的参数，并不能直接执行日志恢复

### Mini-Transaction

- 以组的形式写入redo log
	1. 一组操作，一组日志，不可分割



