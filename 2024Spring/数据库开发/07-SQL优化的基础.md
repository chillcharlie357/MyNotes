---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 07-SQL优化的基础
date:  2024-05-13 14:05
modified:  2024-05-13 14:05
---


**关系代数核心**：等价变换->可以自动对表达式做等价变换，做查询路径优化

# SQL与查询优化器

group by, order by不属于关系代数，无法被查询优化器优化

- 过程
	1. 优化器借助关系理论提供的语义无误的原始查询进行**有效的等价变换**
	2. 优化器根据数据库的实际情况对理论上等价的不同优化方案**做出权衡**
	3. 产生可能的**最优查询执行方案**
	4. 实际将一个SQL查询优化成更高效的方案

- 类型
	1. RBO基于规则的优化器：给每个算子赋值一个权重，计算整个查询的总权重
	2. CBO基于成本的优化器：还要考虑结果集大小
		- 优化目标：中间结果集的数量最少

## 基于成本的优化


### 优化主要方向-连接

驱动表T1执行一次，被驱动表T2执行T1的扇出次
![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F13%2F14-35-14-f6afd0bad0226e9242274e5f936168f0-20240513143513-c05bd0.png)


左外连接
右外连接
T1 T2左外连接，T1记录都保留，T2如果没有相等的，结果集中是空值


基于索引的连接优化：通过索引读取有限条的T2数据与T1连接

基于块的连接优化：

### 连接小结：

本质上，连接就是把各个表中的路径都取出来依次进行匹配，并把匹配的组合返回
外连接和内连接的本质都是确定驱动表
嵌套循环连接算法：驱动表连接一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少记录
被驱动表会被连接多次，可以用索引加速

### 成本计算

I/O成本：物理读写
CPU成本：比较，逻辑读写
...



### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价(row, data_length)
3. 计算使用不同索引的代价
4. 对比各个查询优化方案的代价，找到成本最低的访问方式

**好条件先做**

SQL->表达式->树->不断调整树的节点，找到最优执行路径->得到执行计划：可执行的代码

### 两表连接的成本分析


1. 连接查询的总成本 = 单次访问驱动表的成本 + 驱动表扇出 * 单词被驱动表的成本
2. 不同驱动表的成本不一样，寻找成本最低的那个
3. 扇出值是估算，根据条件占比计算

多表连接类似


## SQL的执行顺序


1. SQL
2. 语法语义检查
3. **解析**：最消耗资源的步骤，选择最优执行路径，
4. 执行计划
5. 执行引擎
6. 存储引擎
7. 数据库


## 软解析：绑定变量


- 防止SQL注入攻击

不把SQL串组合起来之后直接放到查询优化器里，而是先保留变量生成执行计划后再代入变量


```sql
SELECT
FROM
WHERE A=a
```
变量a作为执行计划的参数传入，而不是直接拼到SQL串里


- 把相似查询当成同一个查询，只是参数不同
	- 如果查询与数据值有关，绑定变量导致无法优化，如`WHERE 3 < x < 5`

```sql
WHERE x = 5
WHERE x = 3
//把所有常量编程变量
WHERE x = A
```