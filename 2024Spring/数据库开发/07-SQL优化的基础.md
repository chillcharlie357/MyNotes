---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 07-SQL优化的基础
date:  2024-05-13 14:05
modified:  2024-05-13 14:05
---


**关系代数核心**：等价变换->可以自动对表达式做等价变换，做查询路径优化

# 1. SQL与查询优化器

group by, order by不属于关系代数，无法被查询优化器优化

- 过程
	1. 优化器借助关系理论提供的语义无误的原始查询进行**有效的等价变换**
	2. 优化器根据数据库的实际情况对理论上等价的不同优化方案**做出权衡**
	3. 产生可能的**最优查询执行方案**
	4. 实际将一个SQL查询优化成更高效的方案

- 类型
	1. RBO基于规则的优化器：给每个算子赋值一个权重，计算整个查询的总权重
	2. CBO基于成本的优化器：还要考虑结果集大小
		- 优化目标：中间结果集的数量最少

## 1.1. 基于成本的优化


### 1.1.1. 优化主要方向-连接

驱动表T1执行一次，被驱动表T2执行T1的扇出次
![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F13%2F14-35-14-f6afd0bad0226e9242274e5f936168f0-20240513143513-c05bd0.png)


左外连接
右外连接
T1 T2左外连接，T1记录都保留，T2如果没有相等的，结果集中是空值


基于索引的连接优化：通过索引读取有限条的T2数据与T1连接

基于块的连接优化：

### 1.1.2. 连接小结：

本质上，连接就是把各个表中的路径都取出来依次进行匹配，并把匹配的组合返回
外连接和内连接的本质都是确定驱动表
嵌套循环连接算法：驱动表连接一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少记录
被驱动表会被连接多次，可以用索引加速

### 1.1.3. 成本计算

I/O成本：物理读写
CPU成本：比较，逻辑读写
...



### 1.1.4. 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价(row, data_length)
3. 计算使用不同索引的代价
4. 对比各个查询优化方案的代价，找到成本最低的访问方式

**好条件先做**

SQL->表达式->树->不断调整树的节点，找到最优执行路径->得到执行计划：可执行的代码

### 1.1.5. 两表连接的成本分析


1. 连接查询的总成本 = 单次访问驱动表的成本 + 驱动表扇出 * 单词被驱动表的成本
2. 不同驱动表的成本不一样，寻找成本最低的那个
3. 扇出值是估算，根据条件占比计算

多表连接类似


## 1.2. SQL的执行顺序


1. SQL
2. 语法语义检查
3. **解析**：最消耗资源的步骤，选择最优执行路径，
4. 执行计划
5. 执行引擎
6. 存储引擎
7. 数据库


## 1.3. 软解析：绑定变量

- **绑定变量**：把所有常量变成变量
	- 数据库一般不默认启用
	- 但ORM框架一般默认绑定变量，处于安全性考虑
- 好处：
	1. 相似查询使用变量，当成一个查询。实现软解析。
	2. 避免sql串的拼接，防止注入
- 缺点：
	1. 绑定变量之后，无法通过范围查询的范围估计扇出数量，进而估计最优查询路径。只能使用平均值估算。
### 1.3.1. 防止SQL注入攻击

不把SQL串组合起来之后直接放到查询优化器里，而是先保留变量生成执行计划后再代入变量


```sql
SELECT
FROM
WHERE A=a
```
变量a作为**执行计划的参数**传入，而不是直接拼到SQL串里


### 1.3.2. 把相似查询当成同一个查询，只是参数不同


- 如果查询与数据值有关，**绑定变量**导致无法优化，如`WHERE 3 < x < 5`

硬解析：相似查询当成多条查询，单独执行，数据值固定。
```sql
WHERE x = 5
WHERE x = 3
//把所有常量编程变量
WHERE x = A//绑定变量
```



## 1.4. 优化器只能对关系领域进行优化

order by，group by等不属于关系代数的操作无法优化，是脱离关系代数独立执行的


例子：查询不适经理的员工中，工资最高的五个人？
```sql
%% rownum是ORACLE方言 %%

%% wrong %%
%% order by在前面的查询全部完成后再排序，就是只查询前5条 %%
select empname, salary
from employees
where status != 'EXEC'
and rownum <= 5
order by salary desc

%% right %%
%% 选择出符合条件并排序后，再选择前5条 %%
select *
from (
select empname, salary
from employees
where status != 'EXEC'
order by salary desc
)
where rownum <= 5
```


- **有效范围**
	1. 优化器需要借助数据库中找到的信息
	2. 能够数据意义上等价变化
	3. 优化器考虑整体响应时间
	4. 优化器改善的是独立的查询


## 1.5. 优化器自动条件化解

1. 移除不必要的括号
	1. select from (t1, (t2, t3))
	2. select from t1, t2, t3
2. 常量传递
3. 移除没用的条件
4. 表达式计算：**只会对右侧修改，不会修改左侧**
	1. a=5+1
	2. a=6
	3. 注意：-a<8, a-1=6优化器不会优化
		- 语法语义检查的时候，无法预测左侧是不是函数索引f(x)
5. having子句和where子句合并
	1. 没有聚合函数，group by子句时
6. 常量表检查，当成常量使用
	1. 查询表中，只有一条或者没有记录
	2. 使用主键或唯一的二级索引键的等值查询


## 1.6. 使用SQL需要考虑的因素

1. 获得结果集所需访问的数据量（表大小）
2. 定义结果集所需的查询条件
	- 过滤条件：where子句
3. 结果集的大小
4. 获得结果集所涉及表的数量
	- 表的数量，from子句，不要超过5-8张表
5. 同时修改这些数据用户的多少


