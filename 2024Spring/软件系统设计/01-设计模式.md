---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 01-设计模式
date:  2024-03-05 15:03
modified:  2024-03-12 15:03
---

现有设计经验的总结

<span style="background:rgba(3, 135, 102, 0.2)">模式</span>：问题和约束可以反复使用

创建型模式
结构型模式
行为型模式
# 1. 策略模式

- Strategy/Policy

- 使用哪些原则
	1. 单一职责
		- 封装变化
		- Seperation
	2. 依赖倒转
	3. 合成复用

delegate: 委托另外一个模块，通过引用调用  
OOA到OOD：添加辅助类，设计初期会增加复杂性

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F12%2F14-37-37-53dc9f064dcdb11e211ae203d0259599-20240312143736-b6618c.png)

## 1.1. 定义

完成的任务+实现的方式

- 让算法的变化独立于使用它的客户端
- 定义一个可变的算法族，并将它们封装起来

## 1.2. 适用性

1. 相关的类只在某些行为上不同，每个类在这些行为上都有合适的策略（多个类）
2. 同一个算法需要不同的实现
3. 算法封装不同数据结构
4. 一个类定义了有很多行为，使用条件判断觉得使用哪个行为（一个类里有多种行为）

## 1.3. 影响

原来不需要知道类的细节，但使用策略模式之后需要暴露细节，客户必须理解每一种策略的差异和哪些任务适合哪些细节

Design Pattern比Framework更高层

# 简答工厂模式

## 定义

- Simple Factory Pattern/**Static** Factory Pattern
	- 往往是静态方法
- 根据参数不同，返回不同类的实例
	- 复用创建方法
- 属于**类创建型模式**

- 原则
	- **最小知识原则**，构造方法无法抽象但是可以封装

## 结构

- Factory: 工厂角色
- Product: 抽象产品角色
- ConcreteProduct: 具体产品角色

返回的是抽象的产品类，符合依赖倒置原则

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F14%2F10-17-26-a63018931228b260ae9da7f7aeb1dba0-20240314101726-ac4967.png)

## 分析

1. **将对象的创建和具体业务处理分离**，降低系统耦合（把具体耦合替换成抽象耦合），使得两者修改起来更容易。
2. 工厂方法是静态方法，而且只需要传入简单参数，因此可以把调用时需要传入的参数写在配置文件中，无需修改Java源代码。
3. 工厂类的职责过重，增加新的产品需要修改工厂类判断逻辑，**违反开闭原则**
4. 当你需要什么，只需要传入一个正确的参数，就可以获取对象，**无需知道其创建的细节**。

## 扩展

有些情况下可以把静态工厂方法放到抽象产品类中

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F14%2F10-33-17-8e30d001e58b752bbf746d3aef0ec7a9-20240314103317-a0af9d.png)


# 工厂方法模式

## 动机

简单工厂违反了开闭原则

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F14%2F10-42-47-ee6ae83a65865e7aaebcaa147db1d7fb-20240314104246-a53678.png)


使用抽象工厂，抽象的工厂方法只负责生产抽象的产品类，把具体的按钮了创建过程嫁给专门的工厂子类来完成。
![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F14%2F10-45-25-50e1182ffc8e7412de926403cb44dffa-20240314104525-767af3.png)

## 定义

- Factory Method Pattern/ Virtual Constructor/ Polymorphic Factory
	- 工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象
	- 目的是将产品类的**实例化**操作**延迟**到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类
- 可以时间不修改原有代码的情况下，增加新的产品

## 结构

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F14%2F10-48-20-0f42807ca082ce9b366dc8932c32e92a-20240314104819-bab085.png)

用户代码只使用抽象层，与具体实现解耦