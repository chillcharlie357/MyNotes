---
aliases: 
tags:
  - 2024_Spring_软件系统设计
  - 课程
categories: 2024_Spring_软件系统设计
sticky: 
thumbnail: 
cover: 
excerpt: false
mathjax: true
comment: true
title: 软件系统设计-pmx期末
date:  2024-06-11 15:06
modified:  2024-06-23 14:06
---

# 1. 重点

## 1.1. 题型

- 简答题
	1. 设计原则之间的关系
	2. 设计模式之间的关系
	3. 设计原则和设计模式之间的关系
	4. 架构分析方法和概念
- 设计题：
	- 给出一个设计问题，回答设计方案
	- 设计两三个设计模式联合设计

## 1.2. 设计模式

### 1.2.1. 基本要素

1. 模式名称
2. 问题
3. 解决方案
4. 效果：可以作为约束条件的一部分

### 1.2.2. 分类

- 目的
	1. 创建型：创建对象
	2. 结构型：处理类和对象的组合
	3. 行为型：描述对类或对象怎样交互和怎样分配职责
- 范围
	1. 类模式：式处理类和子类之间的关系，这些关系通过继承建立， 在编译时刻就被确定下来，是属于**静态**的。
	2. 对象模式：处理对象间的关系，这些关系在运行时刻变化，更具**动态**性

- 模式和模式的变体，不同

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F19%2F14-03-56-f7eba1b50144117a2d8052de51950d35-20240619140355-d9b953.png)

### 1.2.3. 设计模式与类库框架

- 为什么不设计一个设计模式的库？
	- 设计模式比库更高层。设计模式告诉我们怎么构建类和对象来解决特定问题，我们需要做的是使用这些原则来适应具体的应用。
- 库和框架是不是设计模式？
	- 框架和类不是设计模式。它们提供了可以连接到代码中的具体实现。但是优势库和框架会在它们的实现中应用设计模式。如果你理解了设计模式，你可以更快理解框架和库的API。

## 1.3. 设计原则

设计原则之间的关系

- 目标：
	1. 可复用
	2. 可维护
- 设计原则
	1. **单一职责原则**要求在软件系统中，一个类只负责一个功能领域中的相应职责。
	2. **开闭原则**要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。
	3. **里氏代换原则**可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。
	4. **依赖倒转原则**要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。
	5. **接口隔离原则**要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。
	6. **合成复用原则**要求复用时尽量使用对象组合，而不使用继承。
	7. **迪米特法则**要求一个软件实体应当尽可能少的与其他实体发生相互作用。
- 目标：开闭原则
- 指导：最小知识原则/迪米特
- 基础：单一职责原则、封装可变性原则
- 实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则

# 整理

## 设计原则之间的关系

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F23%2F11-22-54-d0863b5868bc217b2df809f178845bd0-20240623112253-38708f.png)

- 目标：开闭原则
- 指导：最小知识原则/迪米特
- 基础：单一职责原则、封装可变性原则
- 实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则

## 设计模式和设计原则的关系

### 策略模式

- 使用原则：
	1. 单一职责
	2. 依赖倒转
	3. 合成复用

### 简单工厂模式

- 使用原则
	1. 最小知识原则：构造方法无法抽象但是可以封装
	2. 依赖倒转原则：工厂返回产品的抽象类，降低与产品具体创建方法的耦合
- 违反：
	- 开闭原则：增加新的产品需要修改工厂类判断逻辑

### 工厂方法模式

- 使用原则
	1. 依赖倒置
	2. 单一职责
- 对开闭原则支持很好

### 抽象工厂模式

- 使用原则
	1. 依赖倒转原则：有抽象工厂类和产品类
	2. 单一职责原则：每个具体工厂只生产一个具体产品族
- **开闭原则的倾斜性**
	- **增加新的具体工厂和产品族很方便**，符合开闭原则
	- 不能完全支持开闭原则，<font color="#c00000">需要增加新的产品等级结构时需要修改抽象类</font>

### 原型模式

好像没有使用什么原则？

- 违背开闭原则：**需要为每一个类配备一个克隆方法**，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难。但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码



### 状态模式

- 使用原则
	1. 依赖倒转原则
	1. 
- 开闭原则支持不好：增加新的状态要修改负责状态转换的源代码。