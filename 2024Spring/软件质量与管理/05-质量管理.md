---
aliases: 
tags: 
categories: 2024_Spring_软件质量管理
sticky: 
thumbnail: 
cover: 
excerpt: false
mathjax: true
comment: true
title: 05-质量管理
date:  2024-05-07 10:05
modified:  2024-05-26 16:05
---

<font color="#c00000">管理定义：目标定义，状态跟踪，纠偏</font>

# 1. 质量策略

## 1.1. 质量概念

1. 软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”。[ANSI/IEEE STd 729]
2. 软件质量为内外两部分的特性：其外部质量特性面向软件产品的最终用户，其内部质量特性则不直接面向最终用户。 《代码大全》
3. 软件质量为软件产品可以改变世界，使世界更加美好的程度。从用户的角度考察软件质量，用户满意度是最为重要的判断标准。 [Tom Demarco]
4. 软件质量为对人（用户）的价值。这一定义强调了质量的主观性，即对同一款软件而言，不同的用户对其质量有不同的体验。 [Gerald Weinberg]

内部，外部，主观

## 1.2. 面向用户的质量观

- 定义质量为满足用户需求的程度
	1. 用户是谁？
		- 客户不一定是用户
	2. 用户需求是否有优先级？
		- 很用户对软件的期望有关
	3. 这种用户优先级对软件产品的开发过程产生什么样的影响？
	4. 怎样来度量这种质量观下的质量水平？

软件可工作，可度量：优先级高

## 1.3. PSP质量策略

1. <font color="#c00000">用缺陷管理代替质量管理</font>
	1. **缺陷管理的正当性**：如果软件没有缺陷，其他质量属性也会比较好。
	2. 安全，隐私，交互友好等几乎都无法有效管理
2. 高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷
3. 各组件的高质量是通过**高质量评审**来实现的
	1. **测试是获取质量状态的手段**，而不是提高质量的手段
	2. 经验数据：假设项目缺陷综述确定（但我们不知道），测试团队的消除缺陷能力稳定，测试的时候发现一个错误就有一个没发现的错误，所以**希望暴露出来的错误越少越好**

重视Code Review  
一旦缺陷到了系统级，消除成本会很高，所以要在早期消除

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F11-30-25-59455ef6704a5fcaf74d7e6dfb12abdb-20240507113024-e75a5a.png)

## 1.4. 测试消除缺陷的典型流程

1. 发现待测程序的一个异常行为
2. 理解程序的工作方式
	- Measure twice, cut once
3. 调试程序，找出出错的位置，确定出错原因
4. 确定修改方案，修改缺陷
5. 回归测试，以确认修改有效

## 1.5. 质量指标

过程度量：在过程中度量出来数值，根据这个数值还有机会在过程中修正  
结果度量：算出来就没法修改

### 1.5.1. Yield

缺陷消除的效率，度量每个阶段在消除缺陷方面的效率，**结果度量**

Phase Yield = 100 * 某阶段发现的缺陷个数 / （某阶段注入缺陷个数 + 进入该阶段前遗留的缺陷个数）  
Process Yield = 100 * 第一次编译前发现的缺陷个数 / 第一次编译前注入的缺陷个数

问题：知道分子，但是不知道分母

设计、编码注入缺陷  
评审、测试消除缺陷

### 1.5.2. A/FR

**质检失效时间比**，过程度量

A/FR = PSP质检成本/PSP失效成本  
设计评审时间 / 测试时间

理论上 A/FR越大，意味着质量越高，说明评审越充分  
2.0是比较理想的值

### 1.5.3. PQI

<font color="#c00000">最全面</font>

- 5个数据的**乘积**，每个分量都在[0,1]内
	1. 设计质量：设计时间应该大于编码时间
		- min{设计时间/编码时间, 1}
	2. 设计评审质量：设计评审的时间应该大于设计时间的50%
		- min{(2 * 设计评审时间 / 设计时间), 1}
	3. 代码评审质量：代码评审时间应该大于编码时间的50%
		- min{(2 * 代码评审时间)/编码时间 , 1}
	4. 代码质量：代码的编译缺陷密度应该小于10个/千行
		- min{20/(编译缺陷密度 + 10), 1}
	5. 程序质量：代码单元测试的缺陷密度应该小于5个/千行
		- min{10/(单元测试缺陷密度 + 5), 1}

123过程，45结果，在一个指标里**包含了过程和结果**

PQI达到0.4，说明模块很不错  
大部分人的PQI都是0

### 1.5.4. Review Rate

评审速度：一个用于指导软件工程师有效评审的指标，**过程度量**

高质量的评审需要软件工程师投入足够的时间进行评审

在PSP的实践中，代码评审速度小于200LOC/H，文档评审速度小于4 Page/H

### 1.5.5. DRL

缺陷消除效率比值：不同缺陷消除手段消除缺陷的效率，**结果度量**

计算：某个阶段每小时消除缺陷个数 / 单元测试每小时消除个数

期望：所有DRL都大于1，即单元测试缺陷个数最少

### 1.5.6. 其他质量

个人评审和小组评审（标志重捕法）

Z：总缺陷  
a 评审者1独立发现的缺陷  
b 评审者2发现缺陷  
c 评审者2发现的1发现的缺陷

$$
\frac{a}{Z-a} = \frac{c}{b-c}
$$

先评审再单元测试：先评审解决一些问题，测试时需要修复的问题少一些，需要的时间也少

### 1.5.7. 质量路径

为了追求高质量的手段：

1. 各种测试
2. 进入测试之前的产物质量提升
	- 各种评审
3. 评审过程度量和稳定
	- 评审阶段yield稳定
4. 质量意识和主人翁意识
5. 个体Review的态度和稳定
6. 诉诸设计
	- 终极手段，review测试都用上了还是没达到质量要求
7. 缺陷预防
	- 从这一步开始不是针对特定项目
	- 根据历史项目制定checklist
8. 用户质量观——其他质量属性
	- 前面都是解决缺陷问题，从8开始解决用户质量观的其他质量问题

# 2. 设计与质量的关系

## 2.1. 设计的内容

完整设计（可评审设计）包含以下4个方面

|      | 动态信息         | 静态信息           |
| ---- | :----------- | -------------- |
| 外部信息 | 交互信息（服务、消息等） | 功能（继承、类结构等）    |
| 内部信息 | 行为信息（状态机）    | 结构信息（属性、业务逻辑等） |

## 2.2. UML常用图

|      | 动态信息    | 静态信息                 |
| ---- | ------- | -------------------- |
| 外部信息 | 用例图，时序图 | 类图（只有signature，没有实现） |
| 内部信息 | 状态机图    | **缺失**               |

## 2.3. 设计的层次：PSP模板

1. 操作规格模板
2. 功能规则模板
3. 状态规则模板
4. 逻辑规则模板

## 2.4. 设计验证方法

- 意义
	- 简单评审不足以发现复杂缺陷
- 方法
	1. 状态机验证
	2. 符号化执行验证
	3. 执行表验证
	4. 跟踪表验证
	5. 正确性验证

### 2.4.1. 状态机验证

PSP的状态机用文本描述

## 2.5. 符号化执行

用符号替换关键的变量

可以用来验证复杂算法，但不适合有复杂逻辑的场景

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-38-07-974e78db785a3ca75c18e9f637815699-20240523153806-fe65a9.png)

## 2.6. 执行表验证

- 主要争对伪代码：
	1. 识别伪码程序的关键变量；
	2. 构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；
	3. 初始化被选定的变量；
	4. 跟踪被选择的关键变量的变化情况，从而判断程序行为。

伪代码+关键变量  
**问题：只能检验一个样例**  
![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-41-05-d96a2bf74aac7c649fddb16cf2d896a8-20240523154105-9e1e9c.png)

## 2.7. 跟踪表

伪代码+关键变量

1. 识别伪码程序的关键变量；
2. 构建表格，表格左侧填入主要程序步骤（伪代码），右侧填入关键变量；
3. 初始化被选定的变量；
4. **识别将伪码程序符号化的机会，并加以符号化**；
5. **定义并且优化用例组合**；
6. 跟踪被选择的关键变量的变化情况，从而判断程序行为。

## 2.8. 正确性检验

- 用形式化语言描述程序，加以验证和推理
	1. 分析和识别用例；
	2. 对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证；
	3. 对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证
