---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 02-历史与演变
date:  2024-03-05 10:03
modified:  2024-03-12 11:03
---

# 1. 软件开发三大阶段

1. 软硬件一体化阶段（50年代~70年代）
    1. 软件完全依附于硬件
    2. 软件作坊
2. 软件成为独立的产品（70年代~90年代）
3. 网络化和服务化（90年代中期迄今）

# 2. 软硬件一体化

## 2.1. 典型特征

## 2.2. 典型的软件过程和实践

1. "Measure twice, cut once"：对应<span style="background:rgba(3, 135, 102, 0.2)">代码审查</span>，因为早期开发过程中机器很贵/人力资源便宜

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F10-31-39-29ca6a8d313198dbe4561784f77f99c5-20240305103137-772dc3.png)

# 3. 软件作坊

## 3.1. 典型特征

- 软件应用典型特征
	1. 功能简单
	2. 规模小
- 软件开发的典型特征
	1. 很多非专业领域的人员涌入软件开发领域
	2. 高级程序设计语言的出现
	3. 质疑权威文化的盛行

## 3.2. 典型软件过程和实践

1. <span style="background:rgba(3, 135, 102, 0.2)">code and fix</span>：非常适合小规模团队
2. 软件工程和<span style="background:rgba(3, 135, 102, 0.2)">软件危机</span>：code and fix不适合大型软件开发

# 4. 软件成为独立产品

## 4.1. 典型特征

1. 摆脱了硬件束缚（OS）
2. 功能强大
3. 规模和复杂度剧增
4. 个人电脑出现 => 普通人成为软件用户
	1. 需求多变
	2. 兼容性要求
5. 来自市场的压力

## 4.2. 典型软件过程和实践

### 瀑布

1. 形式化方法
2. 结构化程序设计和<span style="background:rgba(3, 135, 102, 0.2)">瀑布模型</span>
	- 最早期的瀑布模型(Royce Waterfall Model)其实可以回溯，有试错过程
	- 但后来的瀑布模型不能往回

<span style="background:rgba(163, 67, 31, 0.2)">左边才是真正的瀑布模型</span>

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F11-21-53-71b18599d32010fc1b873fcbbdb93eee-20240305112152-b43dd0.png)

### 成熟度模型

- <span style="background:rgba(3, 135, 102, 0.2)">成熟度模型</span>：列出很多最佳实践，划分为5个等级，<span style="background:rgba(3, 135, 102, 0.2)">123低等级（眼前），45高等级（未来）</span>
	- 几乎可以描述所有“可以用过程描述”的事情
	- level 1 粗放
	- level 2 管理：以项目小组为单位，每个小组都有自己的规范
	- level 3 裁剪组织的规范
	- level 4 要收集很多数据，剔除异常点，使用统计方法，有预测模型
	- level 5 发现之前的模型有问题，会做根本性变化（去掉/增加一些过程），重新构建模型

- <span style="background:rgba(3, 135, 102, 0.2)">管理特征</span>
	1. 目标
	2. 状态
	3. 纠偏

- "项目进度落后20%，就要加班"是 level1/2/3，<span style="background:rgba(3, 135, 102, 0.2)"> 只根据已经发生的事情来决策，没有模型只有数据，属于低等级的管理</span>。
	- 这里的20%是指团队整体觉得进度整体落后，只是感觉

![Characteristics_of_Capability_Maturity_Model.svg](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F11-38-09-6f1b39d6c60675925d8546cdac256dc4-Characteristics_of_Capability_Maturity_Model-a3bdd5.svg)

### 4.2.1. 讨论

1. CMMI是<span style="background:rgba(3, 135, 102, 0.2)">过程改进模型</span>而不是软件过程或软件过程模型
2. <font color="#c00000">CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较。</font>CMMI表示的不是公司的绝对能力，刻画的是公司再满足它自己的业务目标的能力。
	- 一线大公司很可能是CMMI一级。而初创公司可能比起大公司更能满足自己的商业目标。
	- 虽然可以为了提高等级降低商业目标，但是招标时CMMI等级不是唯一标准。
	- 商业目标相同时，可以使用等级比较，如选择供应商
3. 为什么CMMI VS. Agile 是个伪命题？
	- [试论CMM/CMMI不适合在当前软件开发当中应用的原因 - 简书](https://www.jianshu.com/p/b7407257eedb)

# 5. 服务化和网格化

## 5.1. 典型特征

1. 功能复杂，规模更大
2. 用户数量急剧增加(这会带来什么问题)
3. 快速演化和需求不确定
4. 分发方式的变化(SaaS)
	- 功能上线到发布时间很短，对质量要求更高

## 5.2. 典型软件过程和实践

- 迭代式开发：<font color="#c00000">大型软件开发系统的开发过程也是一个逐步学习和交流的过程</font>，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步完成交付。
	- 学习和交流：甲方迭代开发的过程中越来越熟悉软件系统，乙方越来越理解甲方的需求


