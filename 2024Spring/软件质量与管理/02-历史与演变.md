---
aliases: 
tags: 
categories:
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
title: 02-历史与演变
date:  2024-03-05 10:03
modified:  2024-03-19 11:03
---

# 1. 软件开发三大阶段

1. 软硬件一体化阶段（50年代~70年代）
    1. 软件完全依附于硬件
    2. 软件作坊
2. 软件成为独立的产品（70年代~90年代）
3. 网络化和服务化（90年代中期迄今）

<font color="#c00000">软件开发方法=软件过程</font>

# 2. 软硬件一体化

## 2.1. 典型特征

## 2.2. 典型的软件过程和实践

1. "<font color="#c00000">Measure twice, cut once</font>"：对应<span style="background:rgba(3, 135, 102, 0.2)">代码审查</span>，因为早期开发过程中机器很贵/人力资源便宜

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F10-31-39-29ca6a8d313198dbe4561784f77f99c5-20240305103137-772dc3.png)

# 3. 软件作坊/软硬件一体化后期

## 3.1. 典型特征

- 软件应用典型特征
	1. 功能简单
	2. 规模小
- 软件开发的典型特征
	1. 很多非专业领域的人员涌入软件开发领域
	2. 高级程序设计语言的出现
	3. 质疑权威文化的盛行

## 3.2. 典型软件过程和实践

1. <span style="background:rgba(3, 135, 102, 0.2)">code and fix</span>：非常适合小规模团队
2. 软件工程和<span style="background:rgba(3, 135, 102, 0.2)">软件危机</span>：code and fix不适合大型软件开发

# 4. 软件成为独立产品

## 4.1. 典型特征

1. 摆脱了硬件束缚（OS）
2. 功能强大
3. 规模和复杂度剧增
4. 个人电脑出现 => 普通人成为软件用户
	1. 需求多变
	2. 兼容性要求
5. 来自市场的压力

## 4.2. 典型软件过程和实践

### 4.2.1. 瀑布

1. 形式化方法
2. 结构化程序设计和<span style="background:rgba(3, 135, 102, 0.2)">瀑布模型</span>
	- 最早期的瀑布模型(Royce Waterfall Model)其实可以回溯，有试错过程
	- 但后来的瀑布模型不能往回

<span style="background:rgba(163, 67, 31, 0.2)">左边才是真正的瀑布模型</span>

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F11-21-53-71b18599d32010fc1b873fcbbdb93eee-20240305112152-b43dd0.png)

### 4.2.2. 成熟度模型

- <span style="background:rgba(3, 135, 102, 0.2)">成熟度模型</span>：列出很多最佳实践，划分为5个等级，<span style="background:rgba(3, 135, 102, 0.2)">123低等级（眼前），45高等级（未来）</span>
	- 几乎可以描述所有“可以用过程描述”的事情
	- level 1 粗放
	- level 2 管理：以项目小组为单位，每个小组都有自己的规范
	- level 3 裁剪组织的规范
	- level 4 要收集很多数据，剔除异常点，使用统计方法，有预测模型
	- level 5 发现之前的模型有问题，会做根本性变化（去掉/增加一些过程），重新构建模型

- <span style="background:rgba(3, 135, 102, 0.2)">管理特征</span>
	1. 目标
	2. 状态
	3. 纠偏

- "项目进度落后20%，就要加班"是 level1/2/3，<span style="background:rgba(3, 135, 102, 0.2)"> 只根据已经发生的事情来决策，没有模型只有数据，属于低等级的管理</span>。
	- 这里的20%是指团队整体觉得进度整体落后，只是感觉

![Characteristics_of_Capability_Maturity_Model.svg](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F05%2F11-38-09-6f1b39d6c60675925d8546cdac256dc4-Characteristics_of_Capability_Maturity_Model-a3bdd5.svg)

### 4.2.3. 讨论

1. CMMI是<span style="background:rgba(3, 135, 102, 0.2)">过程改进模型</span>而不是软件过程或软件过程模型
2. <font color="#c00000">CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较。</font>CMMI表示的不是公司的绝对能力，刻画的是公司再满足它自己的业务目标的能力。
	- 一线大公司很可能是CMMI一级。而初创公司可能比起大公司更能满足自己的商业目标。
	- 虽然可以为了提高等级降低商业目标，但是招标时CMMI等级不是唯一标准。
	- 商业目标相同时，可以使用等级比较，如选择供应商
3. 为什么CMMI VS. Agile 是个伪命题？
	- [试论CMM/CMMI不适合在当前软件开发当中应用的原因 - 简书](https://www.jianshu.com/p/b7407257eedb)

# 5. 服务化和网格化

## 5.1. 典型特征

1. 功能复杂，规模更大
2. 用户数量急剧增加(这会带来什么问题)
3. 快速演化和需求不确定
4. 分发方式的变化(SaaS)
	- 功能上线到发布时间很短，对质量要求更高

## 5.2. 典型软件过程和实践

### 5.2.1. 迭代式开发

- 迭代式开发：<font color="#c00000">大型软件开发系统的开发过程也是一个逐步学习和交流的过程</font>，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步完成交付。
	- 学习和交流：甲方迭代开发的过程中越来越熟悉软件系统，乙方越来越理解甲方的需求

迭代和增量的区别：迭代重点在学习和交流

TDD：测试驱动开发

### 5.2.2. 敏捷开发

- XP(eXtreme Programing)
	- [极限编程 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh-cn/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B)
	- 偏重与一些工程实践的描述
- [Scrum](https://zh.wikipedia.org/wiki/Scrum)
	- 管理框架和管理实践
	- 只有管理，没有技术
- Kanban
	- 精益生产的具体体验
	- 可视化工作流，限定WIP，管理周期时间

## 5.3. 开源软件开发方法

- 一种基于并行开发模式的软件开发的组织与管理方式
- Linus定律：只要有足够的开发者和测试者，几乎所有问题都会被发现
- 代码管理：严格的代码提供社区审核制度
	- <font color="#c00000">真正能对系统建立信心的是评审而不是测试</font>

- 演化
	- 内部开源：早期公司项目没那么多，时间没那么紧张
	- 众包

## 5.4. 软件应用的典型特征

1. 进一步服务化和网格化（移动是主流）
2. 用户需求的多样性进一步凸显
3. 软件产品和服务的地位变化
4. 错综复杂的部署环境
	- 解决了数量的问题，但是有新的困难如容量预测

# 6. 问题

1. 不属于软件开发的本质难题？
	- 不可见性、复杂性、一致性、可变性
	- 没有~~质量~~

2. 软硬件一体化阶段的典型实践
	- Code and fix
