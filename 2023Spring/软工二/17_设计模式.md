# 可修改性

- 可修改性
	- 实现的可修改性
		- 修改已有实现
		- 例如：修改现有促销策
	- 实现的可扩展性
		- 对新实现的扩展
		- 例：增加新的促销策略
	- 实现的灵活性
		- 对实现的动态配置
		- 例如：动态修改更改某商品对应促销策略


## 实现可修改性

- 接口与实现分离
	- interface定义了规约
	- 实现class实现了规约

- 继承
	- 父类定义规约
	- 子类实现规约

## 实现的灵活性

### 继承
- 优点
	- 可以代码重用
- 缺点
	- 父类接口修改会影响子类
	- 子类创建对象的时候，就决定了其实现的选择，没法再动态的修改

### 组合（接口）

利用接口的组成关系 ，能在实现接口和实现的前提下，体现更好的**灵活**性。前端类和后 端类是组合关系。前段 类重用了后端类的代码

```java
class Backend{
	public int method_2(){
	}
}

class Frontend(){
	public Backend back = new Backend();
	public int method_2(){
		back.method_2()
	}
}
class Client {
	public staic void main(String[] argus){
		Frontend front = new Fontend();
		int i = front.method_2();
	}
}
```

- 优点
	- 前端和后端在接口上不存在耦合性。当后 端接口发送改变的时候，并不会直接影响 到Client代码。 
	- 后端类的实现亦可以动态创建、动态配置 、动态销毁，非常灵活


# 设计模式

- 模式
	- 典型问题
	- 设计分析
	- 解决方案
	- 案例

<font color="#ff0000">策略模式，迭代器考的多</font>

## 策略模式

### 问题：
大型连锁超市
员工：钟点工、月薪制、提成制

### 设计分析

1. 可以把上下文和策略分割为不同的类实现不同的职责。
	- **上下文Context类**负责通过 执行策略实现自己职责；
	- **策略类Strategy**只负责复杂策略的实现


2. 上下文类和策略类之间的关系是用组合比继承更加合适
	 -  如果是继承关系，则上下文类只能在行为的n种实 现里面n选一（对象创建时就选定了策略），而如果是组 合关系，上下文类则可以维护一个策略队列，实现n选多 ，从而达到动态的配置
3. 各种策略则在具体策略类（ConcreteStrategy） 中提供，而向上下文类提供统一的策略接口


### 设计原则

- 减少耦合：减少策略的实用类和实现类的直接耦合
- 依赖倒置：策略类的使用类依赖的是策略类的接口，而不是策略的实现类


![msedge_16-设计模式.pdf_和另外_2_个页面_-_个人_-_Microsoft​_Edge_551_285_1683861392.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/12/8c53fc1781e8b00ddc4eb32abb74c5df_msedge_16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.pdf_%E5%92%8C%E5%8F%A6%E5%A4%96_2_%E4%B8%AA%E9%A1%B5%E9%9D%A2_-_%E4%B8%AA%E4%BA%BA_-_Microsoft%E2%80%8B_Edge_551_285_1683861392.png)

算法族可以相互替换，独立于使用算法的用户
通过调用接口触发具体算法


### 应用场景

- 一个类定义了很多行为，这些行为作为一个switch选择语句的 分支执行部分。策略模式可以**消除这些分支选择**
- 当我们需要同一个行为的不同实现（变体）的时候。

## 抽象工厂模式

在软件系统中，对象的 创建往往是一个比较复 杂而且比较特殊的事情 。往往我们会需要根据 不同类型的对象。如果是普通的方法，我们可以通过多态的形式来体 现不同的行为实现。而**构造方法却无法多态**。

switch涉及类行为考虑策略模式，涉及类创建考虑工厂模式

### 使用原则

1. 职责抽象
   -  抽象对象创建的职责
2. 借口重用
	- 提供对象创建的接口


### 协作

- 通常情况下，只有一个具体的工厂的实例被创建。这个具体工厂对于创建产品这个事情本身有具体的实现。对于创建不同的产品对象，客户应该用不同的具体工厂。
- 抽象工厂转移了产品的创建到其子类具体工厂类中间去。

### 应用场景

1. 帮助系统独立于如何对产品的创建 、构成、表现
2. 灵活配置某个产品族中的某一个
3. 一个产品族的产品应该被一起使用，抽象工厂模式可 以强调这个限制
4. 如果你想提供一个产品的库，抽象工厂模式可以帮助 暴露该库的接口，而不是实现


### 例子

16.4抽象工厂模式 16.17

## 单件模式

无论怎么创建一个类，永远只返回同一个对象

### 设计

1. Private构造方法
2. 只能通过getInstance方法获得Singleton类型的对象的引用
3. 成员变量有一个static类型的引用uniqueInstance
4. getInstance返回uniqueInstance，如果为null则首次创建;否则直接返回。

### 原则

- 指责抽象：隐藏单件创建的实现


## 迭代器模式

只希望去遍历一个聚合结构，但是不希望知道具体是怎样的聚合方式。独立于聚合方式实现一个遍历的方式。

### 设计

- 只需要对**遍历**抽象
	- 是否有下一个元素
	- 得到下一个元素
- 迭代器提供的方法只提供了对集合的**访问**的方法，却屏蔽 了对集合修改的方法，这样就对我们把集合作为参数可以 做到对集合的“值传递”的效果


### 设计原则

1. 减少耦合
	- 减少遍历的使用类和遍历的实现类直接的耦合
2. 依赖倒置


### 应用场景

1. 访问一个聚合对象的内容而无需暴露它的内部实现。
2. 支持对聚合对象的多种遍历。
3. 为遍历不同的聚合结构提供一个统一的接口

