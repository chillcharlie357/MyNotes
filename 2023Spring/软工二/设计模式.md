# 可修改性

- 可修改性
	- 实现的可修改性
		- 修改已有实现
		- 例如：修改现有促销策
	- 实现的可扩展性
		- 对新实现的扩展
		- 例：增加新的促销策略
	- 实现的灵活性
		- 对实现的动态配置
		- 例如：动态修改更改某商品对应促销策略


## 实现可修改性

- 接口与实现分离
	- interface定义了规约
	- 实现class实现了规约

- 继承
	- 父类定义规约
	- 子类实现规约

## 实现的灵活性

### 继承
- 优点
	- 可以代码重用
- 缺点
	- 父类接口修改会影响子类
	- 子类创建对象的时候，就决定了其实现的选择，没法再动态的修改

### 组合（接口）

利用接口的组成关系 ，能在实现接口和实现的前提下，体现更好的**灵活**性。前端类和后 端类是组合关系。前段 类重用了后端类的代码

```java
class Backend{
	public int method_2(){
	}
}

class Frontend(){
	public Backend back = new Backend();
	public int method_2(){
		back.method_2()
	}
}
class Client {
	public staic void main(String[] argus){
		Frontend front = new Fontend();
		int i = front.method_2();
	}
}
```

- 优点
	- 前端和后端在接口上不存在耦合性。当后 端接口发送改变的时候，并不会直接影响 到Client代码。 
	- 后端类的实现亦可以动态创建、动态配置 、动态销毁，非常灵活


# 设计模式

- 模式
	- 典型问题
	- 设计分析
	- 解决方案
	- 案例

# 策略模式

## 问题：
大型连锁超市
员工：钟点工、月薪制、提成制

## 设计分析

1. 可以把上下文和策略分割为不同的类实现不同的职责。
	- **上下文Context类**负责通过 执行策略实现自己职责；
	- **策略类Strategy**只负责复杂策略的实现


2. 上下文类和策略类之间的关系是用组合比继承更加合适
	 -  如果是继承关系，则上下文类只能在行为的n种实 现里面n选一（对象创建时就选定了策略），而如果是组 合关系，上下文类则可以维护一个策略队列，实现n选多 ，从而达到动态的配置
3. 各种策略则在具体策略类（ConcreteStrategy） 中提供，而向上下文类提供统一的策略接口


## 设计原则

- 减少耦合：减少策略的实用类和实现类的直接耦合
- 依赖倒置：策略类的使用类依赖的是策略类的接口，而不是策略的实现类


![msedge_16-设计模式.pdf_和另外_2_个页面_-_个人_-_Microsoft​_Edge_551_285_1683861392.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/12/8c53fc1781e8b00ddc4eb32abb74c5df_msedge_16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.pdf_%E5%92%8C%E5%8F%A6%E5%A4%96_2_%E4%B8%AA%E9%A1%B5%E9%9D%A2_-_%E4%B8%AA%E4%BA%BA_-_Microsoft%E2%80%8B_Edge_551_285_1683861392.png)

算法族可以相互替换，独立于使用算法的用户
通过调用接口触发具体算法


## 应用场景

- 一个类定义了很多行为，这些行为作为一个switch选择语句的 分支执行部分。策略模式可以**消除这些分支选择**
- 当我们需要同一个行为的不同实现（变体）的时候。

# 抽象工厂模式

在软件系统中，对象的 创建往往是一个比较复 杂而且比较特殊的事情 。往往我们会需要根据 不同类型的对象。如果是普通的方法，我们可以通过多态的形式来体 现不同的行为实现。而**构造方法却无法多态**。

switch涉及类行为考虑策略模式，涉及类创建考虑工厂模式

