---
aliases: 
title: 02_处理器管理
tags: 2023Spring操作系统 课程
categories: 2023Spring操作系统
date:  Thursday,June 1st 2023
modified:  Tuesday,June 20th 2023
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
---

# 1. 处理器

2.1  
![msedge_847_443.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/06/1c09e84c56bcc36b7e064bbc7d22c5c2_msedge_847_443.png)

## 1.1. 寄存器

**操作系统是中断驱动的！！！**

中断处理流程2.2.4  
ps  
**操作系统要整体看待**

# 2. 进程

- 进程：
	- 是一个具有一定独立功能的程序关于某个数据集合的一次运动 
	- 操作系统为正在运行程序建立的一个实体

- 进程实体（映像）组成
	- PCB
	- 代码段
	- 数据段

- 形式化定义

## 2.1. 进程举例

相同代码在两个不同数据集上运行，构成两个共享代码的无关进程

共享代码称为**可再入程序**，如编译器

三种状态

挂起

## 2.2. 进程控制块PCB👈

- Process Control Block
- PCB是OS用于记录和刻画进程状态及环境信息的**数据结构**

处于运行状态的进程，现场信息时刻变化，没有意义

标志信息

控制信息

## 2.3. 进程的映像 Process Image

2.2.3

![进程的内存映像示意图](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/09/44c726c335010b6df8b532aad55e6de5_msedge_1128_702.png)

## 2.4. 进程上下文 Process context

用户理解的上下文：虚拟内存（程序、用户、数据栈）+处理器现场  
系统理解的上下文：虚拟内存（程序、用户、数据栈）+处理器现场+pcb+系统栈+系统内存空间

## 2.5. 进程状态转换👈

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2021-19-29.png)

## 2.6. 进程管理

2.10

### 2.6.1. 概念级的OS进程管理软件

系统调用/中断/异常处理程序  
队列管理模块  
进程控制程序  
进程调度程序（独立进程居多）  
**进程通信程序**（多个程序包）  
终端登录与作业控制程序、性能监控程序、审计程序等外围程序

### 2.6.2. 队列管理

进程实现的**队列**模型 (不同的阻塞队列)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/13/1f83877a4444e2e35711f39983f7ea4c_Screenshot%20from%202023-03-13%2014-32-30.png)

### 2.6.3. 原语

- 不能被中断的原子操作
- 使用内核的“开中断”和“关中断”指令完成 

创建  
终止  
阻塞  
唤醒  
切换

## 2.7. 进程通信

# 3. 多线程

2.12

## 3.1. 单线程结构进程

传统进程模型  
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/ff10a1e5c8e15604dee467a49914af87_202303201403426.png)

### 3.1.1. 问题

**并发程序**

- 进程切换开销大
- 进程通信开销大
- 限制了进程并发的粒度
- 降低了并行计算的效率

## 3.2. 多线程结构进程

物理并行  
逻辑并行

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/1c744edabe4f391c70f5fb931fb8f89b_202303201404491.png)

多个执行流通过共享变量而不是OS保护的共享内存，减少沟通开销

## 3.3. KLT与ULT

### 3.3.1. 内核级线程

2.13  
KLT, Kernel-Level Threads

1. 线程管理的所有工作由OS内核来做
2. OS提供了一个应用程序设计接口API，供开发者使用KLT
3. OS直接调度KLT  
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/5ab2a88e3962457b8fccf2ff0045beb9_202303201411715.png)

#### 3.3.1.1. 特点

1. 进程中的一个线程被**阻塞**了，内核能调度同一进程的其它线程占有处理器运行
2. **多处理器环境**中，内核能同时调度同一进程中多个线程并行执行
3. 内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率，提高并发度
4. 应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，**系统开销较大**

### 3.3.2. 用户级线程

ULT, User-Level Threads

早期操作系统

1. 用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境
2. 任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行
3. 线程管理的所有工作都由应用程序完成，内核**没有意识**到线程的存在
	- 应用程序自己管理，使用线程库

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/09cee2f34c89d5bd3fc041028d54aec7_202303201414009.png)

**优化调度**  
定义了用户调度

#### 3.3.2.1. 特点

- **优点**
1. 所有线程管理数据结构均在进程的**用户空间**中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源
2. 允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法
3. 能运行在任何OS上，内核在支持ULT方面 不需要做任何工作  
- **缺点**
1. 不能利用多处理器的优点，OS调度进程， 仅有一个ULT能执行
2. 一个ULT的**阻塞**，将引起整个进程的阻塞

### 3.3.3. Jacketing技术

1. 把阻塞式系统调用改造成非阻塞式的,当线程**陷入系统调用**时，执行jacketing 程序
2. 由jacketing 程序来检查资源使用情况， 以决定是否**执行进程切换**或**传递控制权**给另一个线程

### 3.3.4. 用户级线程 vs. 内核级线程

- ULT适用于解决逻辑并行性问题
- KLT适用于解决物理并行性问题  
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/ec1673918ca2bb17fc7da073d0c69cc5_202303201429000.png)

### 3.3.5. 混合策略

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/0ac4721fc46f3b8a91ebce83bb90a0df_202303201430314.png)

1. 线程创建是**完全**在用户空间做的
2. 单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果
	- ULT与KLT多对多，KLT数量一般小于ULT数量
	- 1对1绑定实现纯KLT
	- n对1实现纯ULT

用户级线程：代码逻辑  
内核级线程：处理器资源分配

#### 3.3.5.1. 特点

1. 组合用户级线程/内核级线程设施
2. 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行
3. 一个应用中的多个用户级线程被映射到一些(**小于等于用户级线程数目**)内核级线程上
4. 程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果
5. 该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点

#### 3.3.5.2. 线程状态

**线程控制块TCB**：与PCB类似，保存线程的执行状态

和进程类似

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/d6c193e15bea300d0e5217d89174c59b_202303201438039.png)

KLT三态，系统调度负责  
 ULT三态，用户调度负责

 活跃态ULT代表绑定KLT的三态  
 活跃态ULT运行时可激活用户调度

非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT

# 4. 处理器调度

高级  
中级  
低级

### 4.1. 处理器调度层次与进程状态转换

进程的七状态模型：

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/20/cc9cd7217735a8aa411227565cc7e41c_202303201514369.png)

高级调度：**作业调度**，把外存的作业调入内存，创建PCB  
中级调度：**内存调度**。把**挂起状态**(内存不足，被暂时调入外存)的进程重新调入内存。  
低级调度：处理机调度，**进程调度**。

## 进程调度的时机

## 调度目标

- CPU利用率

- 系统吞吐量：单位时间完成的作业数量

- **周转时间**

周转时间=完成时间-提交时间  
平均周转时间

带权周转时间=周转时间/运行时间 （必然$\ge 1$）  
平均带权周转时间

- 等待时间：进程/作业处于等待处理机状态时间之和  
等待时间=周转时间-运行时间 - I/O操作时间

- 响应时间：从用户提出请求到首次响应所用的时间

## 调度算法

### 分类

1. FCFS先来先服务
2. **RR**时间片轮换
3. SPN
4. SRT
5. HRRF
6. **Feedback**多级反馈队列
7. SJF短作业优先
8. HRRN高响应比优先

### FCFS

- 非抢占式算法，按照作业**到达时间**先后顺序调度
- 优点
	- 公平
- 缺点
	- 对长作业有利，对短作业不利
- 不会导致饥饿

### SPN短作业优先

- 当前已经到达的**最短执行时间**作业/进程先服务。SJF/SPF非抢占式，**SRTN最短剩余时间优先**抢占式
- 优点
	- 周转时间短
- 缺点
	- 导致饥饿，可能饿死

### HRRF高响应比优先算法

- 每次调度是计算所有进程/作业的**响应比**。选择响应比最高的
	- **响应比=1+等待时间/运行所需时间**
- 非抢占式

### 优先数调度

- 调度时选择优先级最高的作业/进程
- 抢占式/非抢占式都有

就绪队列可能不止一个  

### RR时间片轮转调度算法

- 算法规则：根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片
- 一般用于进程调度
- 抢占式

### 分级调度/反馈队列算法👈

**多队列**策略，反馈循环队列

抢占式为主

- 规则
	1. 设置多级队列，优先级越高时间片越小
	2. 新进程先进入第一级队列，按照FCFS原则排队。时间片用完未结束，会进入下一级队列队尾
	3. k级队列为空，才会允许k+1运行
	4. 被抢占立即的进程会重新放回该级队尾

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/23/87deec236814cc43ba526d5b50befba2_202303231419018.png)

基本思想:

1. 建立多个不同优先级的就绪进程队列
2. 多个就绪进程队列间按照优先数调度
3. 高优先级就绪进程，分配的时间片短
4. 单个就绪进程队列中进程的优先数和时间片相同

### 彩票调度算法👈

在client-server模式中应用

- 基本思想：为进程发放针对系统各种资源（如CPU时间）的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源
- 合作进程之间的彩票交换

实时调度?  
并行调度(多处理器)


