
# 管程

## 背景

信号量机制易出错，编写困难。

例子：互斥量写在了同步量前面。
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-06-01%2010-02-05.png)

## 基本形式

- 管程
	- 对**共享数据结构**进行操作的一组过程
	- 若干公共变量及其说明
	- 把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理，管 程的局部变量只能由该管程的过程存取

**进程只能互斥地调用管程中的过程**。实现：在入口有一个互斥信号量。

``` pascal
TYPE <管程名> = MONITOR
<管程变量说明>;
define <（能被其他模块引用的）过程名列表>;
use <（要引用的模块外定义的）过程名列表>；

procedure <过程名>(<形式参数表>);
begin
	<过程体>；
end;
……
procedure <过程名>(<形式参数表>);
begin
	<过程体>；
end;

begin
	<管程的局部数据初始化语句>；
end;
```

## 条件变量

- 条件变量（condition variables）：当调用管程过程的进程无法运行时，用于阻塞进程的信号量 。一个条件变量就是一个**线程队列(queue)**, 其中的线程正等待某个条件变为真。
- 同步原语wait：当一个管程过程发现无法 继续时（如发现没有可用资源时），它在某些条件变量上执行wait，这个动作引起调用进程阻塞 。
- 同步原语signal：用于释放在条件变量上阻塞的进程。

```java
monitor class Semaphore
{
  private int s := 0
  invariant s >= 0
  private Condition sIsPositive /* associated with s > 0 */

  public method P()
  {
    if s = 0 then wait sIsPositive
    assert s > 0
    s := s - 1
  }

  public method V()
  {
    s := s + 1
    assert s > 0
    signal sIsPositive
  }
}
```



## 霍尔风格(Hoare-style)管程

**阻塞式条件变量**. 发出**通知(signaling)的线程必须等待**被通知(signaled)的线程放弃占用管程（或者离开管程，或者等待某个条件变量）。
也称为_通知且急迫等待_(signal-and-urgent-wait)管程。


### 互斥调用霍尔管程的信号量


```pascal
TYPE interf = RECORD
	mutex : semaphore;
	//调用管程过程前使用的互斥信号量
	next : semaphore; 
	//发出signal的进程挂起自己的信号量 
	next_count : integer; 
	//在next上等待的进程数
END;
```

### 互斥调用霍尔管程的框架

```pascal
P(IM.mutex);
<过程体>;
if IM.next_count > 0 
	then V(IM.next); 
	else V(IM.mutex);
```

### 条件变量

```
x_sem : semaphore;// 与资源相关的信号量

x_count : integer;// 在x_sem上等待的进程数
```

### wait

```pascal
procedure wait(var x_sem : semaphore,var x_count : integer, var IM : interf);
begin
	x_count := x_count + 1;
	if IM.next_count > 0 then V(IM.next); 
		else V(IM.mutex);
	P(x_sem);
	x_count := x_count – 1;
end;
```

### signal

```pascal
procedure signal(var x_sem : semaphore,var x_count : integer, var IM : interf);
begin
	if x-count > 0 then
	begin
		IM.next-count := IM.next-count + 1;
		V(x-sem);
		P(IM.next); // 进入等待调用管程的队列
		IM.next-count := IM.next-count - 1;
	end
end;
```

### 例子

用阻塞式管程实现一个有界的、[线程安全](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 "线程安全")的[栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88 "堆栈"). 即多线程并发访问这个栈时，在任意时刻最多只有一个线程执行push或pop操作。

```java
monitor class SharedStack {
  private const capacity := 10
  private int[capacity] A
  private int size := 0
  invariant 0 <= size and size <= capacity
  private BlockingCondition theStackIsNotEmpty /* associated with 0 < size and size <= capacity */
  private BlockingCondition theStackIsNotFull /* associated with 0 <= size and size < capacity */
  
  public method push(int value)
  {
    if size = capacity then wait theStackIsNotFull
    assert 0 <= size and size < capacity
    A[size] := value ; size := size + 1
    assert 0 < size and size <= capacity
    signal theStackIsNotEmpty and return
  }
  
  public method int pop()
  {
    if size = 0 then wait theStackIsNotEmpty
    assert 0 < size and size <= capacity
    size := size - 1 ;
    assert 0 <= size and size < capacity
    signal theStackIsNotFull  and return A[size]
  }
}
```



### 生产者消费者

```pascal
type producer_consumer=monitor
item B[k]; int in, out; //B[k]表示缓冲单元， in, out是存取指针
int count; //缓冲中产品数
semaphore notfull, notempty; //条件变量
int notfull_count, notempty_count; InterfaceModule IM;
define append,take;
use enter,leave,wait,signal；

void append(item x) {
	enter(IM);
	
	if(count==k) //缓冲已满
		wait(notfull,notfull_count,IM);
	B[in]=x;
	in=(in+1)%k;
	count++; //增加一个产品
	signal(notempty,notempty_count,IM);//唤醒等待消费者
	
	leave(IM);
}

void take(item &x) {
	enter(IM);
	
	if(count==0) //缓冲已空
		wait(notempty,notempty_count,IM);// 没产品，需要等等
	x=B[out];
	out=(out+1)%k;
	count--; //减少一个产品
	signal(notfull,notfull_count,IM);//唤醒等待生产者
	
	leave(IM);
}

process producer_i( ) { //i=1,…,n
item x;
produce(x);
producer_consumer.append(x)
}

process consumer_j( ) { //j=1,…m
item x;
producer_consumer.take(x);
consume(x);
}

```

如果阻塞队列为空，`signal`操作就是空操作.



低级通信原语：信号量，管程
高级通信原语：在传递信号的时候也传递数据


# 进程通信


- 进程交互基本要求：
	- 同步，为实施互斥
	- 通信，为了协作

- 典型的消息传递原语
	- send
	- receive 

## 进程直接通信

thread P -> Q
- 对称直接寻址
	- send(P,msg)
	- receive(Q,msg)
- 非对称直接寻址
	- send(P,msg)
	- receive(id,msg)

需要**内核参与**

### 消息格式

消息头+消息体

消息头：消息类型 目标ID 源ID 消息长度 控制消息

### 信箱机制

- 信箱
	- 保存消息的队列
	- 发送者和接收者之间的共享数据结构

send和receive目标为信箱

#### 算法描述



#### 消息传递解决消费者生产者

```cpp
creat-mailbox(producer); //创建信箱
creat-mailbox(consumer);

void producer_i( ) { //i=1,…,n
message pmsg;
while(true) {
	pmsg = produce();
	send(consumer, pmsg);
}
}

void consumer_j( ) { //j=1,…,m
message cmsg;
while(true) {
	receive (consumer, cmsg);
	consume(csmg);
}
}
cobegin
	producer_i( );
	consumer_j( );
coend

```

## 消息缓冲通信



# 高级进程通信机制


## 基于流

多个进程共享一个消息缓冲区
一些进程写入字符流
一些进程从缓冲区读出字符流
信息交换单位基于字符流，长度任意




## 远程过程调用RPC

- RPC, Remote Procedure Call
	- 采用Client/Server模式
	- 服务器提供服务
	- 客户调用服务



分布式计算环境的进程通信：同步RPC
一发出消息就被阻塞，直到收到服务器的完整回复。

# 死锁

**死锁**：如果在一个进程集合中的每 个进程都在等待只能由该集合中的其他一个进程才 能引发的事件，则称一组进程或系统此时发生死锁。

## 死锁产生

进程推荐顺序不当
PV操作顺序
资源分配
对临时性资源不加限制


## 防止死锁



## 避免死锁

银行家算法

