
# 管程

## 背景

信号量机制易出错，编写困难。

例子：互斥量写在了同步量前面。
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-06-01%2010-02-05.png)

## 基本形式

- 管程
	- 对**共享数据结构**进行操作的一组过程
	- 若干公共变量及其说明
	- 把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理，管 程的局部变量只能由该管程的过程存取

**进程只能互斥地调用管程中的过程**，这种互斥性是编译器实现的。


``` pascal
TYPE <管程名> = MONITOR
<管程变量说明>;
define <（能被其他模块引用的）过程名列表>;
use <（要引用的模块外定义的）过程名列表>；

procedure <过程名>(<形式参数表>);
begin
	<过程体>；
end;
……
procedure <过程名>(<形式参数表>);
begin
	<过程体>；
end;

begin
	<管程的局部数据初始化语句>；
end;
```

## 条件变量

- 条件变量（condition variables）：当调用管程过程的进程无法运行时，用于阻塞进程的信号量 。一个条件变量就是一个**线程队列(queue)**, 其中的线程正等待某个条件变为真。
- 同步原语wait：当一个管程过程发现无法 继续时（如发现没有可用资源时），它在某些条件变量上执行wait，这个动作引起调用进程阻塞 。
- 同步原语signal：用于释放在条件变量上阻塞的进程。

```java
monitor class Semaphore
{
  private int s := 0
  invariant s >= 0
  private Condition sIsPositive /* associated with s > 0 */

  public method P()
  {
    if s = 0 then wait sIsPositive
    assert s > 0
    s := s - 1
  }

  public method V()
  {
    s := s + 1
    assert s > 0
    signal sIsPositive
  }
}
```



## 霍尔风格(Hoare-style)管程

**阻塞式条件变量**. 发出**通知(signaling)的线程必须等待**被通知(signaled)的线程放弃占用管程（或者离开管程，或者等待某个条件变量）。
也称为_通知且急迫等待_(signal-and-urgent-wait)管程。


### 互斥调用霍尔管程的信号量


```pascal
TYPE interf = RECORD
	mutex : semaphore;
	//调用管程过程前使用的互斥信号量
	next : semaphore; 
	//发出signal的进程挂起自己的信号量 
	next_count : integer; 
	//在next上等待的进程数
END;
```

### 互斥调用霍尔管程的框架

```pascal
P(IM.mutex);
<过程体>;
if IM.next_count > 0 
	then V(IM.next); 
	else V(IM.mutex);
```

### 条件变量

```
x_sem : semaphore;// 与资源相关的信号量

x_count : integer;// 在x_sem上等待的进程数
```

### wait

```pascal
procedure wait(var x_sem : semaphore,var x_count : integer, var IM : interf);
begin
	x_count := x_count + 1;
	if IM.next_count > 0 then V(IM.next); 
		else V(IM.mutex);
	P(x_sem);
	x_count := x_count – 1;
end;
```

### signal

```pascal
procedure signal(var x_sem : semaphore,var x_count : integer, var IM : interf);
begin
	if x-count > 0 then
	begin
		IM.next-count := IM.next-count + 1;
		V(x-sem);
		P(IM.next); // 进入等待调用管程的队列
		IM.next-count := IM.next-count - 1;
	end
end;
```

### 例子

用阻塞式管程实现一个有界的、[线程安全](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 "线程安全")的[栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88 "堆栈"). 即多线程并发访问这个栈时，在任意时刻最多只有一个线程执行push或pop操作。

```java
monitor class SharedStack {
  private const capacity := 10
  private int[capacity] A
  private int size := 0
  invariant 0 <= size and size <= capacity
  private BlockingCondition theStackIsNotEmpty /* associated with 0 < size and size <= capacity */
  private BlockingCondition theStackIsNotFull /* associated with 0 <= size and size < capacity */
  
  public method push(int value)
  {
    if size = capacity then wait theStackIsNotFull
    assert 0 <= size and size < capacity
    A[size] := value ; size := size + 1
    assert 0 < size and size <= capacity
    signal theStackIsNotEmpty and return
  }
  
  public method int pop()
  {
    if size = 0 then wait theStackIsNotEmpty
    assert 0 < size and size <= capacity
    size := size - 1 ;
    assert 0 <= size and size < capacity
    signal theStackIsNotFull  and return A[size]
  }
}
```