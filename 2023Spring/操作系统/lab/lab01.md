# t1
## 命令
- bximage:创建虚拟软盘映像
- nasm: 汇编boot.asm生产操作系统(boot.bin)的二进制代码
- dd: 把boot.bin写入软盘
	- `dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc`
		- if：代表输入文件
		- of：代表输出设备
		- bs：代表一个扇区大小
		- count：代表扇区数
		- conv：代表不作其它处理
- `bochs -f bochsrc` : 启动bochs
	- -f : configfile

## boot.asm

![image-code](assets/image-code.png)

`$`:当前地址
`$$`:当前扇区的起始地址

[x86 - What is the difference between Times and Dup in Assembly Language? ](https://softwareengineering.stackexchange.com/questions/165025/what-is-the-difference-between-times-and-dup-in-assembly-language?newreg=f1626a136f5d4aa098cb03bbb585c112)

## bochsrc

bochs的配置文件：

```
megs:32
display_library: sdl2 
floppya: 1_44=a.img, status=inserted
boot: floppy
```

- display_library：Bochs使用的GUI库，一般情况下用sdl2就可以了，如果不支持，尝试x等库
- megs：虚拟机内存大小 (MB)
- floppya：虚拟机外设，软盘为a.img文件
- boot：虚拟机启动方式，从软盘启动

# t2


# t3

[[整数除法]]

使⽤NASM汇编语⾔实现整数除法。 
输⼊：被除数x和除数y ，其中$0\le x,y \le 10^{100}$ 
输出：计算$x \div y$的结果，包括商和余数。若出错则输出错误信息。

nasm -felf32 div.asm && ld  -melf_i386 div.o && ./a.out




# 提问

## 8086有哪5类寄存器？请分别举例说明其作⽤

[x86汇编之——8086寄存器讲解 - 知乎](https://zhuanlan.zhihu.com/p/115915986)

1. 数据寄存器：AX、BX、CX和DX。这些寄存器用于保存数据，例如算术运算的操作数。
2. 指针/偏移寄存器：SP、BP、SI和DI。这些寄存器用于保存内存地址或偏移量。
3. 指令指针：IP。这个寄存器保存下一条要执行的指令的地址。
4. 标志寄存器：FLAGS。这个寄存器包含各种标志，例如零标志（ZF）和进位标志（CF），它们根据算术和逻辑操作的结果设置或清除。
5. 段寄存器：CS、DS、ES和SS。这些寄存器用于保存内存段的地址。


## 有哪些段寄存器，它们的作⽤是什么？

1. CS（代码段寄存器）：保存当前执行代码的段地址。
2. DS（数据段寄存器）：保存当前使用数据的段地址。
3. ES（附加段寄存器）：保存当前使用附加数据的段地址。
4. SS（堆栈段寄存器）：保存当前堆栈的段地址。

## 什么是寻址？8086有哪些寻址⽅式？

寻址是指在执行指令时，确定操作数所在的内存地址或寄存器的过程。

**寻址方式：**
1. 立即寻址：操作数直接包含在指令中，作为指令的一部分。
2. 寄存器寻址：操作数在CPU内部的寄存器中，在指令中指定寄存器号。
3. 直接寻址：操作数在存储器中，指令直接包含有操作数的有效地址。
4. 寄存器间接寻址：操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。
5. 寄存器相对寻址：操作数在存储器中，操作数的有效地址是一个**基址寄存器**（BX、BP）**或变址寄存器**的（SI、DI）内容加上**指令中给定**的8位或16位**位移量**之和。
6. 基址变址寻址：操作数在存储器中，操作数的有效地址由**基址寄存器**之一的内容与**变址寄存器**之一的内容相加得到。
7. 相对基址变址寻址：操作数在存储器中，操作数的有效地址由**基址寄存器**之一的内容**与变址寄存器**之一的内容及指令中给定的8位或16位位**位移量**相加得到。

## 主程序与⼦程序之间如何传递参数？

1. 寄存器传递：将参数存储在寄存器中，子程序可以直接从寄存器中读取参数。
2. 堆栈传递：将参数压入堆栈中，子程序可以从堆栈中弹出参数。
3. 内存传递：将参数存储在内存中，子程序可以通过内存地址访问参数。
4. 通过全局变量传递：将参数存储在全局变量中，子程序可以直接访问全局变量以获取参数。 具体使用哪种方法取决于具体情况，例如参数的数量、大小和类型等因素。

## 解释 boot.asm ⽂件中 org 07c00h 的作⽤。如果去掉这⼀句，整个程序应该怎么修改？

org是Origin的英文缩写，意思为起始地址或源地址。这条伪指令用于指定程序的起始地址，若程序未使用org伪指令，那么编译器会把地址0x0000作为程序的起始地址。程序的起始地址将主要影响绝对地址寻址指令。

修改：在使用绝对地址的地方都加上0x07c00


## 解释 int 10h 的功能。

BIOS中断服务程序INT 10h实现屏幕信息显示相关操作。

## 解释 boot.asm ⽂件中 times 510-(\$-\$$) db 0 的作⽤。

用0填充引导扇区的剩余空间，使其总大小为 512 字节。

`$`:当前地址。
`$$`:当前扇区的起始地址。
引导扇区最后两个字节是magic number `0xaa55`，因此需要填充的长度是`510 - ($ - $$)`

`times`：用来重复执行后面的指令若干次。
`dup`：在定义数组时重复生成初始值。

`db`指的是分配一个字节的内存，后面的参数是初始值。

## 解释 bochsrc 中各参数的含义。

```shell
megs:32
display_library: x
floppya: 1_44=a.img,status=inserted
boot: floppy
```

- `megs`：虚拟机使用的内存大小，单位为兆字节（MB）。
- `display_library: x`：虚拟机显示库，` X Window System`。
- `floppya: 1_44=a.img,status=inserted`：指定虚拟机软盘驱动器A的配置。`1_44`表示支持1.44MB软盘，`a.img`软盘路径，`status=inserted`软盘已经插入驱动器。
- `boot`：指定启动设备，从软盘驱动器A启动


## boot.bin 应该放在软盘的哪⼀个扇区？为什么？

第一个扇区，即引导扇区。

启动时BIOS会读取软盘的第一个扇区，并检查最后两个字节是不是`0x55`和`0xAA`。若是则BIOS认为只是有效的引导扇区，并将其加载到内存地址`0x7c00`处，然后调转到该地址执行程序。

## 为什么不让Boot程序直接加载内核，⽽需要先加载Loader再加载内核？

引导扇区只有512字节，无法写入过于复杂的程序，更无法容纳操作系统。且Boot无法自行修改。
如果先加载Loder，Boot作为助推器，把功能更加强大的引导加载程序Loader加载到内存，可以看作硬件设备向软件移交控制权。一旦Loader引导加载程序开始执行，那么一切都交由我们编写的软件来控制。

## Loader的作⽤有哪些？

1. 检测硬件信息
   - 在实模式下通过BIOS中断服务获取硬件信息
     
2. 处理器模式切换
   - BIOS：实模式
   - 32bit：保护模式
   - 64bit：IA-32e模式
     
3. 向内核传递数据
   - 控制信息
   - 硬件数据信息

## Kernel的作⽤有哪些？

管理计算机的硬件资源，并为上层应用程序提供服务。
- 进程管理：Kernel 负责创建、调度和终止进程，以及管理进程之间的通信和同步。
- 内存管理：Kernel 负责分配和回收内存空间，以及管理虚拟内存和物理内存之间的映射关系。
- 文件系统管理：Kernel 负责管理文件系统，提供文件读写、目录操作等功能。
- 设备驱动程序管理：Kernel 负责加载和卸载设备驱动程序，以及管理设备驱动程序与硬件设备之间的通信。
- 网络协议栈管理：Kernel 负责实现网络协议栈，提供网络通信功能。

