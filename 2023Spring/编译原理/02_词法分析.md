

# 1. 词法分析器
- 输入：程序文本/字符串 s + 词法单元 (token) 的规约
- 输出：词法单元流


![NVIDIA_Share_845_318.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/01/0b8af0fabf500f77c5933bf72e3b2360_NVIDIA_Share_845_318.png)

## 1.1. 分类
- 词法分析器生成器（最简单）
- 手写词法分析器
	- 生产环境下编译器常用（如gcc）
- 自动化词法分析器(最难)

# 2. 词法分析器生成器ANTLR
- 输入：词法单元（token）的规约
- 输出：词法分析器
- **如何形式化规约？**
	- 正则表达式

有空看看这个[C.g4](https://github.com/antlr/grammars-v4/blob/master/c/C.g4)
	不知道词法单元怎么描述？

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-03-06%2012-00-44.png)




## 2.1. ANTLR语法
- 发音`|ant-lər|`
- 小写字母开头：文法
- 大写字母开头：语法
- 优先级：
	- 若某字符串满足多个规则，会优先满足前一个规则。**特例放在前面**
	- 约定：字面量的token优先级高于符号量

- 词法单元
	- 关键字
		- 只包含自己，不需要描述
	- 符号量
		- 一类，需要描述

### 2.1.1. ANTLR v4 中两大冲突解决规则


1. 最前优先匹配: 关键字 vs. 标识符


```g4
BEGIN : 'begin' ;
ID : [a-z]+ ;
```
2. 最长优先匹配: >=, ifhappy, thenext, 1.23

## 2.2. 命令行使用
- alias:
	- `alias grun="java org.antlr.v4.gui.TestRig"`用于调试
	- `alias antlr4="java -jar /usr/local/lib/antlr-4.9.1-complete.jar"`
1. 写一个`.g4`文件
2. 在文件目录下`antlr4 <file>.g4`
3. `javac *.java`
4. `grun <file> <rule> [options]`
例子：
```shell
grun SimpleExpr r -tokens
```

## 2.3. 以编程的方式使用antlr4


以编程方式使用antlr4生成的xxxLexer.java
1. 在g4文件中写`package`语句
	- 如果词法语法分开，一般写在语法部分
```java
@header{
package simpleexpr
}
```
=>所有自动生成的文件都放到包里 

header中所有的代码都会被拷贝到生产的java文件

2. 写一个测试文件
```java
CharStream input = CharStreams.fromStream(is);
SimpleExprLexer lexer = new SimpleExprLexer(input);//把输入程序以字符串的形式传给词法分析器

lexer.getAllTokens().forEach(System.out::println);//lamda表达式
```





## 把词法部分和语法部分分开
不同语言语法部分各不相同，词法却很相似

1. 单独写一个`g4`文件 
```g4
lexer grammer SimpleExprRules;
```
2. 语法部分`import`词法部分即可

[grammer-v4] antlr 官方维护的

## 参考
antlr4权威指南：
- 5.5：识别常见的语法结构
- 15.5：词法规则
- 15.6：通配符与非贪婪子规则
- 12：词法分析器黑魔法（暂时用不到），词法分析高端用法

# 3. 正则表达式
作用：词法单元的形式化规约 
正则表达式是**语法**，正则语言是**语义**

## 概念：
- id:字母开头的字母/数字串
- 字母表：字母和数字等符号集合
- 串：符号构成的有穷序列，含空串
- 语言：id定义的集合，可数个串的集合
	- 空语言与只含有空串的语言不同 
	- 集合运算可以得到新的语言


## 语言运算
- L M并：$L\cup M=\{s | s\in L \vee s\in M\}$ 
- L M连接：$LM=\{st | s\in L \land t \in M \}$
- Kleene闭包： $L^*=\cup^{\infty}_{i=0}L^i$
- L的正闭包：$L^+=\cup^{\infty}_{i=1}L^i$

$L^*(L^+)$允许我们构造**无穷**的集合

## 正则表达式定义

### 语法
字母表:

运算优先级 $()\gt * \gt 连接 \gt |$



### 语义
正则表达式对应的正则语言

$$
a
$$


## 扩展语法
- `.*`默认贪婪匹配
- `.*?`**非贪婪匹配**
- `~[\n]*`匹配除了某些字符外的其他字符


`.`在`.g4`中可以匹配任意符号，但在一些版本的正则表达式中表示除了换行符之外的任意字符 

### 反向引用
`<[hH](1-6)>.*?<\/[hH]\1>*`

r1/r2
向后看
`(?=<expr>)`

向前看
`(?<=<expr>)`


《正则表达式必知必会》

### vim简记法
![NVIDIA_Share_1167_807.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/01/f8c6620382eb9a86fea34c22c9a4370f_NVIDIA_Share_1167_807.png)






# 手写一个词法分析器
**lookahead**

- 过程
	- 向前看
	- 向前走
	- 调整状态
	- 记录关键点
	- 待机回头

本质：不断的识别字符串 