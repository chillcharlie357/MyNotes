---
title: 03_语法分析
tags: 2023_Spring编译原理  课程
categories: 2023_Spring编译原理
date:  2023-03-24 14:00
modified:  星期日 2日 四月 2023 16:37:16
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
---



语法分析部分最困难:解析表达式

# 二义性文法

## 悬空else

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/01c23871cda729ab37d9aa0fba96e416_202303301459442.png)

- 二义性例子:
```c
if a then if b then c else d
```


### 解决

- 解决:实现就近匹配(<font color="#ff0000">antlr4默认</font>)
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/8de80a1a9ea5c24b9df221b65b2f2077_202303301459923.png)

## 运算符的结合性

<font color="#ff0000">antlr4默认左结合</font>，且按照从上到下的顺序定义优先级。
越早展开，优先级就越低，在语法树上的位置就越靠近根节点。
但是一些上古时代的工具无法处理该文法。

![[Pasted image 20230330150240.png]]
```c
1-2-3
```

- 前缀、后缀计算符只能左结合，不需要考虑结合性

### 解决

- 解决：左递归（左结合）
	- 在最左边调用自己

如果增加新的运算符，则需要相应的增加语法单元，很繁琐
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/7a999e0ffd35d2437a499f27b3424f02_202303301514512.png)
其中expr->(((t - t) - t) - t)...
			term-> f * f * f ...


# 语法分析实例

## 函数调用图

- Function Call Graph
- 利用antlr4分析函数调用图,分析函数调用关系


多个参数分隔符分开 `formalPara (',' formalpara)*`


## 计算器

`calc`

## 监听器模式(Listener)
[Fetching Title#1mqa](https://www.geeksforgeeks.org/visitor-design-pattern/)

- 限制: 返回值都是`void`
- 解决: 
	- 标注语法分析树
	- 换成`Visitor`模式

### 标注语法分析树

Antlr4提供
hashmap: 语法树node与标注


## 访问者模式(Visitor)
需要自己写语法树遍历过程

### 目的

- 目的：表示作用于某个对象结构中各元素的操作。访问者模式让你可以在**不改变各元素的类**的前提下定义作用于这些元素的新操作。

### 设计
把源程序视为一颗抽象语法树：

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/d155a7774f79689027fb62b9249656dd_202303302107778.png)

上图中的结构将操作分散到各个类，修改或新增操作很繁琐。

- 解决方法:
	1. 相关方法都放在一个类里(Visitor)
	2. 增加新的方法只需要创建新的类


![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/82adcffa39906d4739e305a9eee6e2b8_202303302132973.png)

- Visitor模式需要定义两个类层次
	- Node层次：接受操作的元素
	- Visitor层次：定义对元素的操作，增加新的操作只需要创建新的Visitor类


- 例:Typecheck
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/b2f707ed3df21a402d5dd1b2dbe9630d_202303302123676.png)
- 调用accept以visitor为参数
- 节点实现accept时会回调visitor的的成员函数（参数是this）。

**双重分派**

参考书籍->设计模式,图解设计模式


# 上下文敏感文法
- Context-Sensitive Grammar (CSG）

# 上下文无关文法

- (Context-Free Grammar (CFG); 上下文无关文法$G$是一个四元组$G=(T,N,S,P)$
	- $T$是**终结符号Terminal**的集合,对应词法分析器的词法单元
	- $N$**非终结符号Non-terminal**集合
	- $S$是**开始Start**符号 $S\in N$且$S$唯一
	- $P$是**产生式Production**集合
$$
A \in N \rightarrow \alpha \in (T \cup N)^{*}
$$
头部/左部(Head)$A$：**单个**非终结符
体部/右部(Body)$\alpha$:非终结符与终结符构成的串，也可以是空串$\epsilon$ 

## EBNF

- [Extended] Backus-Naur form ([E]BNF)

是一种形式化的语法，**用于指定编程语言或其他形式化语言的结构**。它是Backus-Naur形式（BNF）的扩展，最初由John Backus和Peter Naur开发，用于描述Algol编程语言的语法。

EBNF在原来的BNF元符号的基础上增加了几个额外的元符号，这使得语言的语法规范更加简洁和易读。它常用于编程语言的规范，有时也用于描述其他类型的形式语言的语法，如数据库查询语言或标记语言。

## 推导

- Derivation
- 将某个产生式的左边替换成它的右边，每一步推导需要选择替换哪个非终结符号, 以及使用哪个产生式。

最左推导:每次都选则最左边的非终结符.

正则表达式的表达能力<font color="#ff0000">严格弱于</font>上下文无关文法.

# 递归下降的LL(1)语法分析器

Adaptive LL(\*)的基础
分析无二义性文法

**自顶向下**的、
**递归下降**的、
**基于预测分析表**的、
适用于**LL(1) 文法**的、
LL(1) 语法分析器

- 解释:
	- $L$:从左向右 (left-to-right) 扫描输入
	- $L$ : 构建最左 (leftmost) 推导
	- $1$ : 只需向前看一个输入符号便可确定使用哪条产生式

## 自顶向下

从根节点不断展开，直到叶节点都是终结符

- 根节点是文法的起始符号$S$
- 中间节点表示对某个非终结符应用某个产生式进行<font color="#ff0000">推导</font>
- 叶节点是词法单元流$w\$$
	- 仅包含终结符号与特殊的文件结束符 $\$$ (EOF)


### LL含义
- 每次展开选择最左边的（最左推导）
- 从左向右读入词法单元

## 递归下降

- 为每个<font color="#ff0000">非终结符</font>写一个<font color="#ff0000">递归函数</font>内部按需调用其它非终结符对应的递归函数, <font color="#ff0000">下降</font>一层

### 实现框架

实现简单，但是处理能力有限

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/fd9b694801b803b37d5d8699eb41e522_202303311415165.png)
- 选择**产生式**
	- 推导
	- 预测分析表

2-7：模板
- 非终结符：递归调用对应的函数
- 终结符：是否与当前输入指针指向的一致
- 报错

## 预测分析表👈

- 用于确定产生式
- 指明了每个<font color="#ff0000">非终结符</font>在面对不同的<font color="#ff0000">词法单元或文件结束符</font>时, 该选择哪个<font color="#ff0000">产生式 </font>(按编号进行索引) 或者<font color="#ff0000">报错</font> (空单元格)

## LL(1)文法

- 如果文法$G$的预测分析表是**无冲突**的，则$G$是$LL(1)$文法
	- 无冲突: 每个单元格里只有一个产生式 (编号)
- 1：对于当前选择的非终结符，仅根据输入中**当前的词法单元** ($LL(1)$) 即可确定需要使用哪条**产生式**


## 计算预测分析表👈

- $FIRST(\alpha)$是可$\alpha$推导得到的句型的<font color="#ff0000">首终结符号</font>的集合
	- 考虑非终结符$A$的所有生成式，如果它们对应的$FIRST(\alpha)$集合<font color="#ff0000">互不相交</font>, 则只需查看当前输入词法单元, 即可确定选择哪个产生式 (或报错)

对任意生成式**右部**$\alpha \in (N\cup T)^{*}$:
$$
FIRST(\alpha) = \{t\in T \cup \{\epsilon\} | \alpha \stackrel{*}{\Rightarrow} t\beta \vee \alpha \stackrel{*}{\Rightarrow} \epsilon\}
$$

- $FOLLOW(A)$可能在某些句型中<font color="#ff0000">紧跟在 A 右边的终结符</font>的集合
	- 从起始的非终结符开始推导

对任意产生式的**左部非终结符**$A\in N$:
$$
FOLLOW(A)=\{t\in T \cup \{ $\} | \exists s.S\stackrel{*}{\Rightarrow}s\stackrel{\Delta}{=}\beta A t \gamma  \}
$$

考虑产生式$A\rightarrow \alpha$ ,如果$\alpha \stackrel{*}{\Rightarrow} \epsilon$ ,则只有当当前词法单元$t\in FOLLOW(A)$,才选择该产生式
即,非终结符有$\epsilon$产生式，需要看当前指针指向的终结符是否为可能在$\epsilon$后面的终结符


<font color="#ff0000">考试可能会考计算</font>


### FIRST集合算法

- 先计算每个符号$X$的$FIRST(X)$集合

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/4d51b21145e3cfacc6562dd38930c62d_202303312029629.png)

规则2:要检查每一条生成式,$Y_i \Rightarrow \epsilon$不一定FIRST(X)有$\epsilon$,通过规则3才能确定.
不断应用上面的规则, 直到每个 First(X) 都不再变化 (不动点!!!)

- 再计算每个符号串$\alpha$的$FIRST(\alpha)$集合
   
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/1db356806a2e7e68ed4ef79732f49c86_202303312037825.png)


### FOLLOW集合算法

- 先计算每个非终结符$X$的$FOLLLOW(X)$集合

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/c6d2efccde7e81af0e639782a611ab25_202303312041515.png)
规则3:如果$\beta$可能消失,则又回到$A\rightarrow \alpha X$

不断应用上面的规则, 直到每个 Follow(X) 都不再变化

### 构造预测分析表算法

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/c74a6e8d2c153d0c4f8209930d2d5559_202303312101998.png)

等价于:

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/174e533a351201471bdbb121ca7b521f_202303312107695.png)

### 例子

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/b4009eb9e85dc206a5ba5021ecc555b3_202303312053708.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/8eaff02287df1cf97c2a670f6c921502_202303312054915.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/af0c061e50a37d21f85b371bb667fe35_202303312054687.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/229758b3798492ff4fba26ed13811510_202303312102180.png)

$$
FL(Z) \cup FL(Z) \Rightarrow FL(Z) = \Phi
$$
初始值都是空集合

