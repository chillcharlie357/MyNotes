
语法分析部分最困难:解析表达式

# 二义性文法

## 悬空else

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/01c23871cda729ab37d9aa0fba96e416_202303301459442.png)

- 二义性例子:
```c
if a then if b then c else d
```


### 解决

- 解决:实现就近匹配(<font color="#ff0000">antlr4默认</font>)
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/8de80a1a9ea5c24b9df221b65b2f2077_202303301459923.png)

## 运算符的结合性

<font color="#ff0000">antlr4默认左结合</font>，且按照从上到下的顺序定义优先级。
越早展开，优先级就越低，在语法树上的位置就越靠近根节点。
但是一些上古时代的工具无法处理该文法。

![[Pasted image 20230330150240.png]]
```c
1-2-3
```

- 前缀、后缀计算符只能左结合，不需要考虑结合性

### 解决

- 解决：左递归（左结合）
	- 在最左边调用自己

如果增加新的运算符，则需要相应的增加语法单元，很繁琐
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/7a999e0ffd35d2437a499f27b3424f02_202303301514512.png)
其中expr->(((t - t) - t) - t)...
			term-> f * f * f ...


# 语法分析实例

## 函数调用图

- Function Call Graph
- 利用antlr4分析函数调用图,分析函数调用关系


多个参数分隔符分开 `formalPara (',' formalpara)*`


## 计算器

`calc`

## 监听器模式(Listener)
[Fetching Title#1mqa](https://www.geeksforgeeks.org/visitor-design-pattern/)

- 限制: 返回值都是`void`
- 解决: 
	- 标注语法分析树
	- 换成`Visitor`模式

### 标注语法分析树

Antlr4提供
hashmap: 语法树node与标注


## 访问者模式(Visitor)
需要自己写语法树遍历过程

### 目的

- 目的：表示作用于某个对象结构中各元素的操作。访问者模式让你可以在**不改变各元素的类**的前提下定义作用于这些元素的新操作。

### 设计
把源程序视为一颗抽象语法树：

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/d155a7774f79689027fb62b9249656dd_202303302107778.png)

上图中的结构将操作分散到各个类，修改或新增操作很繁琐。

- 解决方法:
	1. 相关方法都放在一个类里(Visitor)
	2. 增加新的方法只需要创建新的类


![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/82adcffa39906d4739e305a9eee6e2b8_202303302132973.png)

- Visitor模式需要定义两个类层次
	- Node层次：接受操作的元素
	- Visitor层次：定义对元素的操作，增加新的操作只需要创建新的Visitor类


- 例:Typecheck
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/b2f707ed3df21a402d5dd1b2dbe9630d_202303302123676.png)
以visitor为参数调用accept,节点实现accept时会回调visitor的的成员函数（参数是this）。

**双重分派**

参考书籍->设计模式,图解设计模式


# 上下文敏感文法
- Context-Sensitive Grammar (CSG）

# 上下文无关文法

- (Context-Free Grammar (CFG); 上下文无关文法$G$是一个四元组$G=(T,N,S,P)$
	- $T$是**终结符号Terminal**的集合,对应词法分析器的词法单元
	- $N$**非终结符号Non-terminal**集合
	- $S$是**开始Start**符号 $S\in N$且$S$唯一
	- $P$是**产生式Production**集合
$$
A \in N \rightarrow \alpha \in (T \cup N)^{*}
$$
头部/左部(Head)$A$：**单个**非终结符
体部/右部(Body)$\alpha$:非终结符与终结符构成的串，也可以是空串$\epsilon$ 

## EBNF

- [Extended] Backus-Naur form ([E]BNF)

是一种形式化的语法，**用于指定编程语言或其他形式化语言的结构**。它是Backus-Naur形式（BNF）的扩展，最初由John Backus和Peter Naur开发，用于描述Algol编程语言的语法。

EBNF在原来的BNF元符号的基础上增加了几个额外的元符号，这使得语言的语法规范更加简洁和易读。它常用于编程语言的规范，有时也用于描述其他类型的形式语言的语法，如数据库查询语言或标记语言。

## 推导

- Derivation
- 将某个产生式的左边替换成它的右边，每一步推导需要选择替换哪个非终结符号, 以及使用哪个产生式。
- 
最左推导:每次都选则最左边的非终结符


正则表达式的表达能力<font color="#ff0000">严格弱于</font>上下文无关文法