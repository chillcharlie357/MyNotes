---
title: 03_语法分析
tags: 2023_Spring编译原理  课程
categories: 2023_Spring编译原理
date:  2023-03-24 14:00
modified:  星期日 2日 四月 2023 16:37:16
sticky:
thumbnail:
cover: 
excerpt: false
mathjax: true
comment: true
---



语法分析部分最困难:解析表达式

# 二义性文法

## 悬空else

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/01c23871cda729ab37d9aa0fba96e416_202303301459442.png)

- 二义性例子:
```c
if a then if b then c else d
```


### 解决

- 解决:实现就近匹配(<font color="#ff0000">antlr4默认</font>)
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/8de80a1a9ea5c24b9df221b65b2f2077_202303301459923.png)

## 运算符的结合性

<font color="#ff0000">antlr4默认左结合</font>，且按照从上到下的顺序定义优先级。
越早展开，优先级就越低，在语法树上的位置就越靠近根节点。
但是一些上古时代的工具无法处理该文法。

![[Pasted image 20230330150240.png]]
```c
1-2-3
```

- 前缀、后缀计算符只能左结合，不需要考虑结合性

### 解决

- 解决：左递归（左结合）
	- 在最左边调用自己

如果增加新的运算符，则需要相应的增加语法单元，很繁琐
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/7a999e0ffd35d2437a499f27b3424f02_202303301514512.png)
其中expr->(((t - t) - t) - t)...
			term-> f * f * f ...


# 语法分析实例

## 函数调用图

- Function Call Graph
- 利用antlr4分析函数调用图,分析函数调用关系


多个参数分隔符分开 `formalPara (',' formalpara)*`


## 计算器

`calc`

## 监听器模式(Listener)
[Fetching Title#1mqa](https://www.geeksforgeeks.org/visitor-design-pattern/)

- 限制: 返回值都是`void`
- 解决: 
	- 标注语法分析树
	- 换成`Visitor`模式

### 标注语法分析树

Antlr4提供
hashmap: 语法树node与标注


## 访问者模式(Visitor)
需要自己写语法树遍历过程

### 目的

- 目的：表示作用于某个对象结构中各元素的操作。访问者模式让你可以在**不改变各元素的类**的前提下定义作用于这些元素的新操作。

### 设计
把源程序视为一颗抽象语法树：

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/d155a7774f79689027fb62b9249656dd_202303302107778.png)

上图中的结构将操作分散到各个类，修改或新增操作很繁琐。

- 解决方法:
	1. 相关方法都放在一个类里(Visitor)
	2. 增加新的方法只需要创建新的类


![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/82adcffa39906d4739e305a9eee6e2b8_202303302132973.png)

- Visitor模式需要定义两个类层次
	- Node层次：接受操作的元素
	- Visitor层次：定义对元素的操作，增加新的操作只需要创建新的Visitor类


- 例:Typecheck
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/30/b2f707ed3df21a402d5dd1b2dbe9630d_202303302123676.png)
- 调用accept以visitor为参数
- 节点实现accept时会回调visitor的的成员函数（参数是this）。

**双重分派**

参考书籍->设计模式,图解设计模式


# 上下文敏感文法
- Context-Sensitive Grammar (CSG）

# 上下文无关文法

- (Context-Free Grammar (CFG); 上下文无关文法$G$是一个四元组$G=(T,N,S,P)$
	- $T$是**终结符号Terminal**的集合,对应词法分析器的词法单元
	- $N$**非终结符号Non-terminal**集合
	- $S$是**开始Start**符号 $S\in N$且$S$唯一
	- $P$是**产生式Production**集合
$$
A \in N \rightarrow \alpha \in (T \cup N)^{*}
$$
头部/左部(Head)$A$：**单个**非终结符
体部/右部(Body)$\alpha$:非终结符与终结符构成的串，也可以是空串$\epsilon$ 

## EBNF

- [Extended] Backus-Naur form ([E]BNF)

是一种形式化的语法，**用于指定编程语言或其他形式化语言的结构**。它是Backus-Naur形式（BNF）的扩展，最初由John Backus和Peter Naur开发，用于描述Algol编程语言的语法。

EBNF在原来的BNF元符号的基础上增加了几个额外的元符号，这使得语言的语法规范更加简洁和易读。它常用于编程语言的规范，有时也用于描述其他类型的形式语言的语法，如数据库查询语言或标记语言。

## 推导

- Derivation
- 将某个产生式的左边替换成它的右边，每一步推导需要选择替换哪个非终结符号, 以及使用哪个产生式。

最左推导:每次都选则最左边的非终结符.

正则表达式的表达能力<font color="#ff0000">严格弱于</font>上下文无关文法.

# 递归下降的LL(1)语法分析器

Adaptive LL(\*)的基础
分析无二义性文法

**自顶向下**的、
**递归下降**的、
**基于预测分析表**的、
适用于**LL(1) 文法**的、
LL(1) 语法分析器

- 解释:
	- $L$:从左向右 (left-to-right) 扫描输入
	- $L$ : 构建最左 (leftmost) 推导
	- $1$ : 只需向前看一个输入符号便可确定使用哪条产生式

## 自顶向下

从根节点不断展开，直到叶节点都是终结符

- 根节点是文法的起始符号$S$
- 中间节点表示对某个非终结符应用某个产生式进行<font color="#ff0000">推导</font>
- 叶节点是词法单元流$w\$$
	- 仅包含终结符号与特殊的文件结束符 $\$$ (EOF)


### LL含义
- 每次展开选择最左边的（最左推导）
- 从左向右读入词法单元

## 递归下降

- 为每个<font color="#ff0000">非终结符</font>写一个<font color="#ff0000">递归函数</font>内部按需调用其它非终结符对应的递归函数, <font color="#ff0000">下降</font>一层

### 实现框架

实现简单，但是处理能力有限

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/fd9b694801b803b37d5d8699eb41e522_202303311415165.png)
- 选择**产生式**
	- 推导
	- 预测分析表

2-7：模板
- 非终结符：递归调用对应的函数
- 终结符：是否与当前输入指针指向的一致
- 报错

## 预测分析表👈

- 用于确定产生式
- 指明了每个<font color="#ff0000">非终结符</font>在面对不同的<font color="#ff0000">词法单元或文件结束符</font>时, 该选择哪个<font color="#ff0000">产生式 </font>(按编号进行索引) 或者<font color="#ff0000">报错</font> (空单元格)

行：终结符
列：词法单元/EOF

## LL(1)文法

- 如果文法$G$的预测分析表是**无冲突**的，则$G$是$LL(1)$文法
	- 无冲突: 每个单元格里只有一个产生式 (编号)
- 1：对于当前选择的非终结符，仅根据输入中**当前的词法单元** ($LL(1)$) 即可确定需要使用哪条**产生式**


## 计算预测分析表👈

- $FIRST(\alpha)$是可$\alpha$推导得到的句型的<font color="#ff0000">首终结符号</font>的集合
	- 考虑非终结符$A$的所有生成式，如果它们对应的$FIRST(\alpha)$集合<font color="#ff0000">互不相交</font>, 则只需查看当前输入词法单元, 即可确定选择哪个产生式 (或报错)

对任意生成式**右部**$\alpha \in (N\cup T)^{*}$:
$$
FIRST(\alpha) = \{t\in T \cup \{\epsilon\} | \alpha \stackrel{*}{\Rightarrow} t\beta \vee \alpha \stackrel{*}{\Rightarrow} \epsilon\}
$$

- $FOLLOW(A)$可能在某些句型中<font color="#ff0000">紧跟在 A 右边的终结符</font>的集合
	- 从起始的非终结符开始推导

对任意产生式的**左部非终结符**$A\in N$:
$$
FOLLOW(A)=\{t\in T \cup \{ $\} | \exists s.S\stackrel{*}{\Rightarrow}s\stackrel{\Delta}{=}\beta A t \gamma  \}
$$

考虑产生式$A\rightarrow \alpha$ ,如果$\alpha \stackrel{*}{\Rightarrow} \epsilon$ ,则只有当当前词法单元$t\in FOLLOW(A)$,才选择该产生式
即,非终结符有$\epsilon$产生式，需要看当前指针指向的终结符是否为可能在$\epsilon$后面的终结符


<font color="#ff0000">考试可能会考计算</font>


### FIRST集合算法

- 先计算每个符号$X$的$FIRST(X)$集合

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/4d51b21145e3cfacc6562dd38930c62d_202303312029629.png)

规则2:要检查每一条生成式,$Y_i \Rightarrow \epsilon$不一定FIRST(X)有$\epsilon$,通过规则3才能确定.
不断应用上面的规则, 直到每个 First(X) 都不再变化 (不动点!!!)

- 再计算每个符号串$\alpha$的$FIRST(\alpha)$集合
   
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/1db356806a2e7e68ed4ef79732f49c86_202303312037825.png)


### FOLLOW集合算法

- 先计算每个非终结符$X$的$FOLLLOW(X)$集合

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/c6d2efccde7e81af0e639782a611ab25_202303312041515.png)
规则3:如果$\beta$可能消失,则又回到$A\rightarrow \alpha X$

不断应用上面的规则, 直到每个 Follow(X) 都不再变化

### 构造预测分析表算法

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/c74a6e8d2c153d0c4f8209930d2d5559_202303312101998.png)

（2）：A可能推导消失，当前终结符需要匹配的就是A的后面一个终结符

等价于:

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/174e533a351201471bdbb121ca7b521f_202303312107695.png)

### 例子

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/b4009eb9e85dc206a5ba5021ecc555b3_202303312053708.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/8eaff02287df1cf97c2a670f6c921502_202303312054915.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/af0c061e50a37d21f85b371bb667fe35_202303312054687.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/03/31/229758b3798492ff4fba26ed13811510_202303312102180.png)

$$
FL(Z) \cup FL(Z) \Rightarrow FL(Z) = \Phi
$$
初始值都是空集合

发现存在冲突，不是LL(1)文法





## 改造非LL(1)文法

### 消除左递归

- 左递归问题：会在不消耗任何终结符的情况下一直循环

#### 改成右递归

复杂，可读性差

#### 直接左递归

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/10/c8e8e1387677fea3e23e9f687e855ec0_202304101417291.png)

#### 间接左递归

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/04/10/9fd1fdfb60519626b1f10ddc7f614df1_202304101413534.png)
$$
A_i \rightarrow A_i\alpha \Rightarrow i \lt j
$$

##### 算法要求

1. 文法中不存在环
2. 文法中不存在$\epsilon$产生式


### 提取做公因子

但是并不能消除文法二义性（if then 例子）


# LL(0)

- 只有一个字符
- 每个终结符唯一对应词法单元



# ALLStar语法分析算法

处理表达式优先级👈

语法错误

可以处理二义性文法




## 优先级上升算法

## 错误处理



# LR0 语法分析器


## 区别

**LL(k)弱点**：在仅看到**右部的前 k 个词法单元**时就必须预测要使用哪条产生式。
**推导**：$A\rightarrow \alpha$，不断展开左部

**LR(k)优点**：看到正在考虑的产生式的**整个右部对应的词法单元**再决定。
**归约**：$A\leftarrow \alpha$，把完整右部不断归约成左部，输入是叶子节点

## LR0

**L**：从左向右扫描输入
**R**:反向最右推导
**0**:归约时不需要向前看，不是指移入的时候

**LR语法分析器：**
- 自底向上
- 不断归约
- 基于**句柄**识别自动机
- 适用于LR文法


## 自底向上

根节点：文法的起始符号S
叶节点：token流w$


## 归约

归约顺序：反向最右推导顺序（right most）

### 语法分析器状态

当前句型：上边缘+剩余输入
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2014-36-05.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2014-27-28.png)

上边缘：使用**栈**存储，包含了语法分析器目前所知的所有信息

栈操作：移入输入符号(且指针后移)，按产生式归约

```
id
F
T
T *
T * id
T * F
T
E

```


## LR分析表

shift 
reduce 归约
goto 
accept

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2014-46-06.png)


栈操作移入终结符，改变状态，查表。
归约分为出栈和入栈操作：出栈时会上一个状态；入栈会压入非终结符会改变状态，查表跳转。

#### 过程


![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2015-01-23.png)


0 $ id s5
5  $id  * r6（先把id弹出去，此时栈里是\$）
0 $F

### 过程算法

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2015-10-37.png)

## 句柄识别自动机

- 定义：句柄(Handle)
	- 在输入串的 (唯一) 反向最右推导中, 如果下一步是逆用产生式 $A\leftarrow \alpha$ 将 $\alpha$ 归约为 A, 则称 $\alpha$是当前句型的句柄。

对实际设计词法分析器没用

- 存在一种LR语法分析算法，保证句柄总是出现在栈顶

- 状态：当前观察到的针对所有产生式的右部的前缀


项：一条产生式的一个前缀
项集：若干项的集合，一个状态
项集族：自动机的状态集


## 初始状态

点指示了栈顶，左边是栈里的内容，右边是期望看到的文法符号串

$E^{'} \rightarrow .E$ 
**初始状态$I_0$** : $CLOSURE\{[E^{'}\rightarrow .E]\}$对增广语法做闭包（展开到点后面是非终结符为止）

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2015-40-16.png)




## 状态跳转



## 接受状态

$F=\{I\in C | \exists [A\rightarrow \alpha .] \in I\}$

产生式的完整右部出现在栈顶，点在最右边



## LR(0)分析表构造

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-24%2015-50-17.png)

GOTO函数拆成ACTION表和GOTO表

GOTO表针对终结符，终结符是在归约过程中产生的，并不是语法分析器一开始就碰到的。
ACTION表针对非终结符

### 构造规则

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-31%2014-12-11.png)

（3）中A不能是开始符号($E\rightarrow E^{'}$)


# LR1


## SLR1

Simple LR1

### 与LR0区别

只需要修改LR0的规则3,非终结符t属于FOLLOW(A)才归约
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-31%2014-21-03.png)


### 定义

如果文法G的SLR1分析表是无冲突的，则G是SLR1文法


#### 非SLR1文法举例
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-31%2014-30-04.png)


FOLLOW集合与状态无关


# LR1

LR1项$[A\rightarrow \alpha . \beta , a] (a\in T \cup \{\$\})$


$\forall b \in FIRST(\beta a). [B\rightarrow .\gamma , b]\in I$
$\beta$可能是$\epsilon$

**初始状态**： $CLOUSURE([S^{'}\rightarrow .S,\$])$

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-31%2015-26-03.png)

主要区别是**归约条件**


虽然强大但分析表太大

# LALR1

- Look Ahead LR1:合并具有**相同核心LR0项**的状态，忽略不同的向前看选项

强度：
LR0 < LALR1  < LR1

LR0项相同，则状态出边也相同，可以合并


## 例

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-31%2015-35-57.png)

先合并没有出边的状态， $I_{47},I_{89}$
然后$I_{36}$

## 合并风险：冲突

- 对LR1文法，LALR1分析表**不会**引入移入/归约冲突。


$A\rightarrow \alpha . ,a$
$B\rightarrow \beta .a \gamma,c$


- LALR1分析表可能会引入归约归约冲突。

$\{[A\rightarrow c.,d],[B\rightarrow c.,e]\}$
$\{[A\rightarrow c.,e],[B\rightarrow c.,d]\}$


