
# 并发控制

## 多事务执行方式

### 事务串行执行

- 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
- 不能充分利用系统资源，发挥数据库共享资源的特点

### 交叉并发方式（Interleaved  Concurrency）


# 不可重复读

幻影：元组的突然出现和消失

是否在乎看语义


# 封锁

- 定义：务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁

对不同粒度的数据对象进行封锁有不同的效果

- 基本锁类型
	- 排它锁（Exclusive Locks，简记为**X锁**），写锁
		- 保证其他事务在T释放A上的锁之前<font color="#ff0000">不能再读取和修改A </font>
		- 锁的是同一个或相关资源，若索取的资源没有关联则不受锁影响
	- 共享锁（Share Locks，简记为**S锁**），读锁
		- 保证其他事务<font color="#ff0000">可以读A</font>，但在T释放A上的S锁之前不能对A做任何修改 

## 封锁协议

- 在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 
	- 何时申请X锁或S锁
	- 持锁时间
	- 何时释放

### 一级封锁协议

#### 定义

- 事务T在<font color="#ff0000">修改数据R</font>之前必须先对其加<font color="#ff0000">X锁</font>，直到事务结束才释放。
	- 正常结束（COMMIT）
	- 非正常结束（ROLLBACK）

#### 作用局限

- 可防止丢失修改，并保证事务T是可恢复的。
- 如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

#### 过程

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/67fa5a1cd7635bd752f281dc408150ba_202305111734244.png)

解锁前COMMIT：一旦解锁就有可能要回滚，所以要先commit

### 二级封锁协议

#### 定义

- 一级封锁协议加上事务T在<font color="#ff0000">读取</font>数据R之前必须先对其加<font color="#ff0000">S锁</font>，**读完后**即可释放S锁。

#### 作用局限

- 防止丢失修改和读“脏”数据。
- 由于读完数据后即可释放S锁，所以它不能保证可重复读。

#### 过程

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/2de37d3614f07764daee9a1bac8fd6d5_202305111738096.png)


$T_1$释放C上的X锁后$T_2$获得C上的S锁，读C=100。避免了T2读“脏”数据

### 三级封锁协议

#### 定义

- 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到**事务结束**才释放。
	- 封锁时间比二级长

#### 作用局限

- 可防止丢失修改、读脏数据和不可重复读。
- 对并发调度限制大

#### 过程

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/a4d6fd53d6bebc800e84b1a3d85c5583_202305111748310.png)

## 活锁

- 任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

- 原因：调度不公平


## 死锁

- 两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

- 例子：
$T_1 -> T_2$
$T_2 -> T_3$
$T_3 -> T_1$

### 预防

- 一次封锁法
	- 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
	- 问题：
		- 降低系统并发度
		- 难于事先精确确定封锁对象

- 顺序封锁法
	- 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁
	- 问题：
		- 维护成本
		- 难以实现

### 诊断

在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点

- 超时法
	- 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁

- 等待图法
	- 并发控制子系统周期性地（比如每隔数秒）生成**事务等待图**，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。
	- 事务等待图就是一个有向图