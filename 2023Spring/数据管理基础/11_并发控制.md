
# 1. 事务
- 恢复和并发控制的基本单位。原子操作。

## 1.1. ACID特性
1. 原子性Atomicity
2. 一致性Consistency
3. 隔离性Isolation
4. 持久性Durability

### 1.1.1. 一致性

事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

- **一致性状态**：数据库中只包含成功事务提交的结果

不一致：发生故障被迫
### 1.1.2. 隔离性

一个事务的执行不能被其他事务干扰
一个事务内部的操作及使用的数据对其他并发事务是隔离的
**并发**执行的各个事务之间不能互相干扰

### 1.1.3. 持久性

一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。


## 1.2. 事务并发的问题

- 会产生多个事务同时存取同一数据的情况 
- 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性

## 1.3. 多事务执行方式

### 1.3.1. 事务串行执行

- 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
- 不能充分利用系统资源，发挥数据库共享资源的特点

### 1.3.2. 交叉并发方式（Interleaved  Concurrency）

1. 在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行
2. 单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率

### 1.3.3. 同时并发方式（simultaneous  concurrency）

多处理机系统
更复杂

# 2. 并发控制

- 事务是并发控制的基本单位

## 2.1. 并发控制机制的任务
- 对并发操作进行正确调度
- 保证事务的隔离性
- 保证数据库的一致性

## 2.2. 并发导致的不一致性

1. 丢失修改（Lost Update）
2. 不可重复读（Non-repeatable Read）
3. 读“脏”数据（Dirty Read）
4. 幻读：
	- 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 

不一致性例子：经典并发银行卡扣钱

**记号**：
- `R(X)`：读数据X
- `W(X)`：写数据X到硬盘

数据库应用有时允许一定程度的不一致性，可以降低对一致性的要求减少系统的开销。

### 2.2.1. 修改丢失

例：

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2016-30-28.png)

两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。

### 2.2.2. 不可重复读

**不可重复读**是指事务T1读取数据后，事务T2执行**更新操作**，使T1无法再现前一次读取结果。

是否在乎要看语义
- 不可重复读包括三种情况， 后两种不可重复读有时也称为幻影现象（Phantom Row，元组的突然出现和消失）：
	1. 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值 
	2. 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。 
	3. 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。

后两种也被称为幻影现象。

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2016-34-52.png)


### 2.2.3. 脏读

**脏读指的是**：事务T1修改某一数据，并将其写回磁盘。事务T2读取同一数据后， T1由于某种原因被撤销。这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致。T2读到的数据就为“脏”数据，即**不正确的数据**

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2016-36-31.png)

此时$T_2$读到的就是脏数据


# 3. 并发控制主要技术

1. 封锁(Locking)
2. 时间戳(Timestamp)
3. 乐观控制法(optimistic scheduler)
4. 多版本并发控制(MVCC)

## 3.1. 封锁

- 定义：事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁

对不同粒度的数据对象进行封锁有不同的效果

- 基本锁类型
	- 排它锁（Exclusive Locks，简记为**X锁**），写锁
		- 保证其他事务在T释放A上的锁之前<font color="#ff0000">不能再读取和修改A </font>
		- 锁的是同一个或相关资源，若索取的资源没有关联则不受锁影响
	- 共享锁（Share Locks，简记为**S锁**），读锁
		- 保证其他事务<font color="#ff0000">可以读A</font>，但在T释放A上的S锁之前不能对A做任何修改 

## 3.2. 封锁协议

- 在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 
	- 何时申请X锁或S锁
	- 持锁时间
	- 何时释放

#### 3.2.1. 一级封锁协议


- 定义：事务T在<font color="#ff0000">修改数据R</font>之前必须先对其加<font color="#ff0000">X锁</font>，直到**事务结束**才释放。
	- 正常结束（COMMIT）
	- 非正常结束（ROLLBACK）


- 作用：**可防止丢失修改**，并保证事务T是可恢复的。
- 局限：如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它**不能保证可重复读和不读“脏”数据**。

##### 3.2.1.1. 例子

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/67fa5a1cd7635bd752f281dc408150ba_202305111734244.png)

解锁前COMMIT：一旦解锁就有可能要回滚，所以要先commit.

###  3.2.2 二级封锁协议


- 定义： 一级封锁协议加上事务T在<font color="#ff0000">读取数据R</font>之前必须先对其加<font color="#ff0000">S锁</font>，**读完后**即可释放S锁。

- 作用：**防止丢失修改**和**防止读“脏”数据**。
- 局限：由于读完数据后即可释放S锁，所以它**不能保证可重复读**。

#### 过程

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/2de37d3614f07764daee9a1bac8fd6d5_202305111738096.png)


$T_1$释放C上的X锁后$T_2$获得C上的S锁，读C=100。避免了T2读“脏”数据

### 三级封锁协议

#### 定义

- 一级封锁协议加上事务T在**读取数据R**之前必须先对其加**S锁**，直到**事务结束**才释放。
	- **封锁时间比二级长**


- 作用：可防止丢失修改、读脏数据和不可重复读。
- 局限：对并发调度限制大

#### 过程

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/imgae/2023/05/11/a4d6fd53d6bebc800e84b1a3d85c5583_202305111748310.png)

事务T1在读A，B之前，先对A，B加S锁
其他事务只能再对A，B加S锁，而不能加X锁，即其他事务只能读A，B，而不能修改
当T2为修改B而申请对B的X锁时被拒绝只能等待T1释放B上的锁
T1为验算再读A，B，这时读出的B仍是100，求和结果仍为150，即可重复读
T1结束才释放A，B上的S锁。 T2才获得对B的X锁 


### 三种协议的区别

- 三级协议的主要区别
	- 什么操作需要申请封锁以及何时释放锁（即持锁时间），主要是S锁的区别
- 不同的封锁协议使事务达到的一致性级别不同
	- 封锁协议级别越高，一致性程度越高

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2016-58-01.png)

## 活锁

- 任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

- 原因：调度不公平


最简单的解决策略是先来先服务。

## 死锁

- 两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

- 例子：

$T_1 -> T_2$
$T_2 -> T_3$
$T_3 -> T_1$

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2017-02-58.png)

### 预防

- 一次封锁法
	- 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
	- 问题：
		- 降低系统并发度
		- 难于事先精确确定封锁对象

- 顺序封锁法
	- 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁
	- 问题：
		- 维护成本
		- 难以实现

### 诊断

在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点

- 超时法
	- 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁

- 等待图法
	- 并发控制子系统周期性地（比如每隔数秒）生成**事务等待图**，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。
	- 事务等待图就是一个有向图

### 解除死锁

- 选择一个处理死锁代价最小的事务，将其撤消
- 释放此事务持有的所有的锁，使其它事务能继续运行下去


# 事务调度

## 可串行调度

可串行化调度：
- 数据库管理系统对并发事务不同的调度可能会产生不同的结果
- 串行调度是正确的
- 执行结果等价于串行调度的调度也是正确的，称为**可串行化调度** 

## 冲突可串行化调度

一个比可串行化更严格的条件，商用系统中的调度器采用

- 冲突操作：指不同的事务对同一数据的读写操作和写写操作
- 不能交换的操作：
	- 同一事务的两个操作
	- 不同事务的冲突操作

### 判断冲突是否可串行化

- 冲突可串行化的调度：
	- 一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，Sc’是串行的
- 若一个调度是冲突可串行化，则一定是可串行化的调度
	- 冲突可串行调度$\Rightarrow$可串行调度
	- 可串行调度$\not{\Rightarrow}$冲突可串行调度

例子：
![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2018-27-25.png)

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2018-31-13.png)

## 两段封锁协议

- 指所有事务必须分两个阶段对数据项加锁和解锁 
	- **扩展阶段**：在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
	- **收缩阶段**：在释放一个封锁之后，事务不再申请和获得任何其他封锁

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2018-34-06.png)

数据库管理系统普遍采用两段锁协议的方法**实现并发调度的可串行性**，从而保证调度的正确性 。

### 性质

1. 事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。
2. 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的
3. 若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议

### 与一次封锁法的区别

- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议

- 两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务**可能发生死锁**

![](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/Screenshot%20from%202023-05-20%2018-38-15.png)


# 封锁粒度

封锁粒度：封锁对象的大小

## 多粒度封锁

- 多粒度封锁树：根节点是整个数据库，叶节点是最小的封锁力度。

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F06%2F09%2Fdfb6fe4e8aea28e1b4cb28bdfa1cfd73_20230609201702.png)

- 多粒度封锁协议：对一个节点加锁，则他的子节点也加锁。

显示封锁：直接加到数据对象上
隐式封锁：祖先节点被封锁

- **加锁检查**：
	- 自身
	- 子节点
	- 祖先节点
都没有冲突才能上锁。


## 意向锁

- 对一个节点加上意向锁，说明它的下层节点正在被加锁。对任意节点加锁时，必须先对它的上层节点加意向锁。

### IS锁

- 意向共享锁，表示它的后裔节点拟加S锁。
	- 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁 

### IX锁

- 意向排他锁，表示它的后裔节点拟加X锁。
	- 例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁 

### SIX锁

- 表示该对象先加S锁，再加IX锁
	- 例如对某个表加SIX锁，表示事务要读整个表(S)，同时更新个别元组(IX)。

### 相容矩阵

![image.png](https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F06%2F09%2F9bb0250378a2a97a9fe51dec3abff148_20230609202344.png)

事务在加锁时申请强锁来代替弱锁是安全的，反之不然。

申请封锁自上而下，释放封锁自下而上。

### 作用

提高了系统的并发度
减少了加锁和解锁的开销
在实际的数据库管理系统产品中得到广泛应用 
